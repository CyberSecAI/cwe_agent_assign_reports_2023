{
  "retriever": "dense",
  "query": "## Vulnerability Description\nThe package react-native-reanimated before 3.0.0-rc.1 are vulnerable to Regular Expression Denial of Service (ReDoS) due to improper usage of regular expression in the parser of Colors.js.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper regular expression usage**\n- **impact:** regular expression denial of service\n- **product:** react-native-reanimated\n- **version:** before 3.0.0-rc.1\n- **component:** parser in Colors.js\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's an analysis of CVE-2022-24373:\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from a regular expression used to parse numbers within the `react-native-reanimated` library's `Colors.ts` file. This regex was susceptible to a Regular Expression Denial of Service (ReDoS) attack.\n\n**Weaknesses/Vulnerabilities Present:**\n- **ReDoS:** The original regex `^[-+]?\\\\d*\\\\.?\\\\d+$` could cause excessive backtracking when processing malicious input strings. This is due to the optional components `\\\\d*` and `\\\\.?` which can match in multiple ways. This could lead to a denial-of-service state by consuming excessive CPU resources.\n- The initial fix introduced a new regex: `^[-+]?\\\\d*(?:\\\\.\\\\d*)?$`. This regex, while preventing the ReDoS vulnerability, had a flaw by matching an empty string.\n- The final fix introduced a new regex `[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)` that is safe from ReDos and also prevents empty string matches.\n\n**Impact of Exploitation:**\n- A successful ReDoS attack could lead to a denial of service, causing the application to become unresponsive due to high CPU usage. This would prevent legitimate users from accessing and using the application.\n\n**Attack Vectors:**\n- An attacker could craft malicious input strings designed to exploit the vulnerable regular expression when parsing color values. If the application uses user-supplied data to parse color values, this could be a point of attack.\n\n**Required Attacker Capabilities/Position:**\n- The attacker needs to control or influence the input string that is passed to the vulnerable regex. This might be possible through user input fields, data from external APIs, or other sources of data that is parsed by the application. The attacker can be remote.\n\n**Additional Details:**\n\n- The vulnerability was addressed by replacing the vulnerable regex with a non-vulnerable one in this commit: [https://github.com/software-mansion/react-native-reanimated/pull/3382/commits/7adf06d0c59382d884a04be86a96eede3d0432fa](https://github.com/software-mansion/react-native-reanimated/pull/3382/commits/7adf06d0c59382d884a04be86a96eede3d0432fa)\n- The initial fix had an issue matching empty strings and this was fixed in PR [#3419](https://github.com/software-mansion/react-native-reanimated/pull/3419)\n- The fix was included in version 3.0.0-rc.1\n- Snyk provides a severity score of 5.3 (medium) and NVD provides a score of 7.5 (high). Snyk also provides an EPSS score of 0.21%.\n- The fix involves changing the regex to ensure there is always only one possible path to take given any input. This avoids excessive backtracking and prevents a ReDoS attack.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.386 |\n| 2 | 185 | Incorrect Regular Expression | Class | Allowed-with-Review | sparse | 0.231 |\n| 3 | 777 | Regular Expression without Anchors | Variant | Allowed | sparse | 0.221 |\n| 4 | 625 | Permissive Regular Expression | Base | Allowed | sparse | 0.212 |\n| 5 | 186 | Overly Restrictive Regular Expression | Base | Allowed | sparse | 0.212 |\n| 6 | 1287 | Improper Validation of Specified Type of Input | Base | Allowed | dense | 0.510 |\n| 7 | 187 | Partial String Comparison | Variant | Allowed | graph | 0.003 |\n| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.204 |\n| 9 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.204 |\n| 10 | 626 | Null Byte Interaction Error (Poison Null Byte) | Variant | Allowed | sparse | 0.193 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-1333: Inefficient Regular Expression Complexity\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.\n\n### Extended Description\nSome regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. \n\n### Alternative Terms\nReDoS: ReDoS is an abbreviation of \"Regular expression Denial of Service\".\nRegular Expression Denial of Service: While this term is attack-focused, this is commonly used to describe the weakness.\nCatastrophic backtracking: This term is used to describe the behavior of the regular expression as a negative technical impact.\n\n### Relationships\nChildOf -> CWE-407\nChildOf -> CWE-407\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n- **CVE-2021-21317:** npm package for user-agent parser prone to ReDoS due to overlapping capture groups\n- **CVE-2019-16215:** Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.\n\n\n\n\n## CWE-185: Incorrect Regular Expression\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product specifies a regular expression in a way that causes data to be improperly matched or compared.\n\n### Extended Description\nWhen the regular expression is used in protection mechanisms such as filtering or validation, this may allow an attacker to bypass the intended restrictions on the incoming data.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-697\nCanPrecede -> CWE-187\nCanPrecede -> CWE-182\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** While there is some overlap with allowlist/denylist problems, this entry is intended to deal with incorrectly written regular expressions, regardless of their intended use. Not every regular expression is intended for use as an allowlist or denylist. In addition, allowlists and denylists can be implemented using other mechanisms besides regular expressions.\n\n**[Research Gap]** Regexp errors are likely a primary factor in many MFVs, especially those that require multiple manipulations to exploit. However, they are rarely diagnosed at this level of detail.\n\n\n\n### Observed Examples\n- **CVE-2002-2109:** Regexp isn't \"anchored\" to the beginning or end, which allows spoofed values that have trusted values as substrings.\n- **CVE-2005-1949:** Regexp for IP address isn't anchored at the end, allowing appending of shell metacharacters.\n- **CVE-2001-1072:** Bypass access restrictions via multiple leading slash, which causes a regular expression to fail.\n\n\n\n\n## CWE-777: Regular Expression without Anchors\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product uses a regular expression to perform neutralization, but the regular expression is not anchored and may allow malicious or malformed data to slip through.\n\n### Extended Description\nWhen performing tasks such as validating against a set of allowed inputs (allowlist), data is examined and possibly modified to ensure that it is well-formed and adheres to a list of safe values. If the regular expression is not anchored, malicious or malformed data may be included before or after any string matching the regular expression. The type of malicious data that is allowed will depend on the context of the application and which anchors are omitted from the regular expression.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-625\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-30034:** Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).\n\n\n\n\n## CWE-625: Permissive Regular Expression\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression that does not sufficiently restrict the set of allowed values.\n\n### Extended Description\n\n\nThis effectively causes the regexp to accept substrings that match the pattern, which produces a partial comparison to the target. In some cases, this can lead to other weaknesses. Common errors include:\n\n\n  - not identifying the beginning and end of the target string\n\n  - using wildcards instead of acceptable character ranges\n\n  - others\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-185\nPeerOf -> CWE-187\nPeerOf -> CWE-184\nPeerOf -> CWE-183\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2021-22204:** Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.\n- **CVE-2006-1895:** \".*\" regexp leads to static code injection\n- **CVE-2002-2175:** insertion of username into regexp results in partial comparison, causing wrong database entry to be updated when one username is a substring of another.\n\n\n\n\n## CWE-186: Overly Restrictive Regular Expression\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA regular expression is overly restrictive, which prevents dangerous values from being detected.\n\n### Extended Description\nThis weakness is not about regular expression complexity. Rather, it is about a regular expression that does not match all values that are intended. Consider the use of a regexp to identify acceptable values or to spot unwanted terms. An overly restrictive regexp misses some potentially security-relevant values leading to either false positives *or* false negatives, depending on how the regexp is being used within the code. Consider the expression /[0-8]/ where the intention was /[0-9]/. This expression is not \"complex\" but the value \"9\" is not matched when maybe the programmer planned to check for it.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-185\nCanAlsoBe -> CWE-184\nCanAlsoBe -> CWE-183\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Can overlap allowlist/denylist errors (CWE-183/CWE-184)\n\n\n\n### Observed Examples\n- **CVE-2005-1604:** MIE. \".php.ns\" bypasses \".php$\" regexp but is still parsed as PHP by Apache. (manipulates an equivalence property under Apache)\n\n\n\n\n## CWE-1287: Improper Validation of Specified Type of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.\n\n### Extended Description\n\n\nWhen input does not comply with the expected type, attackers could trigger unexpected errors, cause incorrect actions to take place, or exploit latent vulnerabilities that would not be possible if the input conformed with the expected type.\n\n\nThis weakness can appear in type-unsafe programming languages, or in programming languages that support casting or conversion of an input to another type.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nPeerOf -> CWE-843\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2008-2223:** SQL injection through an ID that was supposed to be numeric.\n\n\n\n\n## CWE-187: Partial String Comparison\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product performs a comparison that only examines a portion of a factor before determining whether there is a match, such as a substring, leading to resultant weaknesses.\n\n### Extended Description\nFor example, an attacker might succeed in authentication by providing a small password that matches the associated portion of the larger, correct password.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-1023\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is conceptually similar to other weaknesses, such as insufficient verification and regular expression errors. It is primary to some weaknesses.\n\n\n\n### Observed Examples\n- **CVE-2014-6394:** Product does not prevent access to restricted directories due to partial string comparison with a public directory\n- **CVE-2004-1012:** Argument parser of an IMAP server treats a partial command \"body[p\" as if it is \"body.peek\", leading to index error and out-of-bounds corruption.\n- **CVE-2004-0765:** Web browser only checks the hostname portion of a certificate when the hostname portion of the URI is not a fully qualified domain name (FQDN), which allows remote attackers to spoof trusted certificates.\n\n\n\n\n## CWE-674: Uncontrolled Recursion\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion\n\n### Relationships\nChildOf -> CWE-834\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2007-1285:** Deeply nested arrays trigger stack exhaustion.\n- **CVE-2007-3409:** Self-referencing pointers create infinite loop and resultant stack exhaustion.\n- **CVE-2016-10707:** Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.\n\n\n\n\n## CWE-617: Reachable Assertion\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.\n\n### Extended Description\n\n\nWhile assertion is good for catching logic errors and reducing the chances of reaching more serious vulnerability conditions, it can still lead to a denial of service.\n\n\nFor example, if a server handles multiple simultaneous connections, and an assert() occurs in one single connection that causes all other connections to be dropped, this is a reachable assertion that leads to a denial of service.\n\n\n### Alternative Terms\nassertion failure\n\n### Relationships\nChildOf -> CWE-670\nChildOf -> CWE-670\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2006-6767:** FTP server allows remote attackers to cause a denial of service (daemon abort) via crafted commands which trigger an assertion failure.\n- **CVE-2006-6811:** Chat client allows remote attackers to cause a denial of service (crash) via a long message string when connecting to a server, which causes an assertion failure.\n\n\n\n\n## CWE-626: Null Byte Interaction Error (Poison Null Byte)\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not properly handle null bytes or NUL characters when passing data between different representations or components.\n\n### Extended Description\n\n\nA null byte (NUL character) can have different meanings across representations or languages. For example, it is a string terminator in standard C libraries, but Perl and PHP strings do not treat it as a terminator. When two representations are crossed - such as when Perl or PHP invokes underlying C functionality - this can produce an interaction error with unexpected results. Similar issues have been reported for ASP. Other interpreters written in C might also be affected.\n\n\nThe poison null byte is frequently useful in path traversal attacks by terminating hard-coded extensions that are added to a filename. It can play a role in regular expression processing in PHP.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-147\nChildOf -> CWE-436\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** Current usage of \"poison null byte\" is typically related to this C/Perl/PHP interaction error, but the original term in 1998 was applied to an off-by-one buffer overflow involving a null byte.\n\n**[Research Gap]** There are not many CVE examples, because the poison NULL byte is a design limitation, which typically is not included in CVE by itself. It is typically used as a facilitator manipulation to widen the scope of potential attacks against other vulnerabilities.\n\n\n\n### Observed Examples\n- **CVE-2005-4155:** NUL byte bypasses PHP regular expression check\n- **CVE-2005-3153:** inserting SQL after a NUL byte bypasses allowlist regexp, enabling SQL injection\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\nThe package react-native-reanimated before 3.0.0-rc.1 are vulnerable to Regular Expression Denial of Service (ReDoS) due to improper usage of regular expression in the parser of Colors.js.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper regular expression usage**\n- **impact:** regular expression denial of service\n- **product:** react-native-reanimated\n- **version:** before 3.0.0-rc.1\n- **component:** parser in Colors.js\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's an analysis of CVE-2022-24373:\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from a regular expression used to parse numbers within the `react-native-reanimated` library's `Colors.ts` file. This regex was susceptible to a Regular Expression Denial of Service (ReDoS) attack.\n\n**Weaknesses/Vulnerabilities Present:**\n- **ReDoS:** The original regex `^[-+]?\\\\d*\\\\.?\\\\d+$` could cause excessive backtracking when processing malicious input strings. This is due to the optional components `\\\\d*` and `\\\\.?` which can match in multiple ways. This could lead to a denial-of-service state by consuming excessive CPU resources.\n- The initial fix introduced a new regex: `^[-+]?\\\\d*(?:\\\\.\\\\d*)?$`. This regex, while preventing the ReDoS vulnerability, had a flaw by matching an empty string.\n- The final fix introduced a new regex `[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)` that is safe from ReDos and also prevents empty string matches.\n\n**Impact of Exploitation:**\n- A successful ReDoS attack could lead to a denial of service, causing the application to become unresponsive due to high CPU usage. This would prevent legitimate users from accessing and using the application.\n\n**Attack Vectors:**\n- An attacker could craft malicious input strings designed to exploit the vulnerable regular expression when parsing color values. If the application uses user-supplied data to parse color values, this could be a point of attack.\n\n**Required Attacker Capabilities/Position:**\n- The attacker needs to control or influence the input string that is passed to the vulnerable regex. This might be possible through user input fields, data from external APIs, or other sources of data that is parsed by the application. The attacker can be remote.\n\n**Additional Details:**\n\n- The vulnerability was addressed by replacing the vulnerable regex with a non-vulnerable one in this commit: [https://github.com/software-mansion/react-native-reanimated/pull/3382/commits/7adf06d0c59382d884a04be86a96eede3d0432fa](https://github.com/software-mansion/react-native-reanimated/pull/3382/commits/7adf06d0c59382d884a04be86a96eede3d0432fa)\n- The initial fix had an issue matching empty strings and this was fixed in PR [#3419](https://github.com/software-mansion/react-native-reanimated/pull/3419)\n- The fix was included in version 3.0.0-rc.1\n- Snyk provides a severity score of 5.3 (medium) and NVD provides a score of 7.5 (high). Snyk also provides an EPSS score of 0.21%.\n- The fix involves changing the regex to ensure there is always only one possible path to take given any input. This avoids excessive backtracking and prevents a ReDoS attack.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.386 |\n| 2 | 185 | Incorrect Regular Expression | Class | Allowed-with-Review | sparse | 0.231 |\n| 3 | 777 | Regular Expression without Anchors | Variant | Allowed | sparse | 0.221 |\n| 4 | 625 | Permissive Regular Expression | Base | Allowed | sparse | 0.212 |\n| 5 | 186 | Overly Restrictive Regular Expression | Base | Allowed | sparse | 0.212 |\n| 6 | 1287 | Improper Validation of Specified Type of Input | Base | Allowed | dense | 0.510 |\n| 7 | 187 | Partial String Comparison | Variant | Allowed | graph | 0.003 |\n| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.204 |\n| 9 | 617 | Reachable Assertion | Base | Allowed | sparse | 0.204 |\n| 10 | 626 | Null Byte Interaction Error (Poison Null Byte) | Variant | Allowed | sparse | 0.193 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-1333: Inefficient Regular Expression Complexity\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.\n\n### Extended Description\nSome regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. \n\n### Alternative Terms\nReDoS: ReDoS is an abbreviation of \"Regular expression Denial of Service\".\nRegular Expression Denial of Service: While this term is attack-focused, this is commonly used to describe the weakness.\nCatastrophic backtracking: This term is used to describe the behavior of the regular expression as a negative technical impact.\n\n### Relationships\nChildOf -> CWE-407\nChildOf -> CWE-407\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n- **CVE-2021-21317:** npm package for user-agent parser prone to ReDoS due to overlapping capture groups\n- **CVE-2019-16215:** Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.\n\n\n\n\n## CWE-185: Incorrect Regular Expression\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product specifies a regular expression in a way that causes data to be improperly matched or compared.\n\n### Extended Description\nWhen the regular expression is used in protection mechanisms such as filtering or validation, this may allow an attacker to bypass the intended restrictions on the incoming data.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-697\nCanPrecede -> CWE-187\nCanPrecede -> CWE-182\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** While there is some overlap with allowlist/denylist problems, this entry is intended to deal with incorrectly written regular expressions, regardless of their intended use. Not every regular expression is intended for use as an allowlist or denylist. In addition, allowlists and denylists can be implemented using other mechanisms besides regular expressions.\n\n**[Research Gap]** Regexp errors are likely a primary factor in many MFVs, especially those that require multiple manipulations to exploit. However, they are rarely diagnosed at this level of detail.\n\n\n\n### Observed Examples\n- **CVE-2002-2109:** Regexp isn't \"anchored\" to the beginning or end, which allows spoofed values that have trusted values as substrings.\n- **CVE-2005-1949:** Regexp for IP address isn't anchored at the end, allowing appending of shell metacharacters.\n- **CVE-2001-1072:** Bypass access restrictions via multiple leading slash, which causes a regular expression to fail.\n\n\n\n\n## CWE-777: Regular Expression without Anchors\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product uses a regular expression to perform neutralization, but the regular expression is not anchored and may allow malicious or malformed data to slip through.\n\n### Extended Description\nWhen performing tasks such as validating against a set of allowed inputs (allowlist), data is examined and possibly modified to ensure that it is well-formed and adheres to a list of safe values. If the regular expression is not anchored, malicious or malformed data may be included before or after any string matching the regular expression. The type of malicious data that is allowed will depend on the context of the application and which anchors are omitted from the regular expression.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-625\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-30034:** Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).\n\n\n\n\n## CWE-625: Permissive Regular Expression\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression that does not sufficiently restrict the set of allowed values.\n\n### Extended Description\n\n\nThis effectively causes the regexp to accept substrings that match the pattern, which produces a partial comparison to the target. In some cases, this can lead to other weaknesses. Common errors include:\n\n\n  - not identifying the beginning and end of the target string\n\n  - using wildcards instead of acceptable character ranges\n\n  - others\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-185\nPeerOf -> CWE-187\nPeerOf -> CWE-184\nPeerOf -> CWE-183\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2021-22204:** Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.\n- **CVE-2006-1895:** \".*\" regexp leads to static code injection\n- **CVE-2002-2175:** insertion of username into regexp results in partial comparison, causing wrong database entry to be updated when one username is a substring of another.\n\n\n\n\n## CWE-186: Overly Restrictive Regular Expression\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA regular expression is overly restrictive, which prevents dangerous values from being detected.\n\n### Extended Description\nThis weakness is not about regular expression complexity. Rather, it is about a regular expression that does not match all values that are intended. Consider the use of a regexp to identify acceptable values or to spot unwanted terms. An overly restrictive regexp misses some potentially security-relevant values leading to either false positives *or* false negatives, depending on how the regexp is being used within the code. Consider the expression /[0-8]/ where the intention was /[0-9]/. This expression is not \"complex\" but the value \"9\" is not matched when maybe the programmer planned to check for it.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-185\nCanAlsoBe -> CWE-184\nCanAlsoBe -> CWE-183\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Can overlap allowlist/denylist errors (CWE-183/CWE-184)\n\n\n\n### Observed Examples\n- **CVE-2005-1604:** MIE. \".php.ns\" bypasses \".php$\" regexp but is still parsed as PHP by Apache. (manipulates an equivalence property under Apache)\n\n\n\n\n## CWE-1287: Improper Validation of Specified Type of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.\n\n### Extended Description\n\n\nWhen input does not comply with the expected type, attackers could trigger unexpected errors, cause incorrect actions to take place, or exploit latent vulnerabilities that would not be possible if the input conformed with the expected type.\n\n\nThis weakness can appear in type-unsafe programming languages, or in programming languages that support casting or conversion of an input to another type.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nPeerOf -> CWE-843\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2008-2223:** SQL injection through an ID that was supposed to be numeric.\n\n\n\n\n## CWE-187: Partial String Comparison\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product performs a comparison that only examines a portion of a factor before determining whether there is a match, such as a substring, leading to resultant weaknesses.\n\n### Extended Description\nFor example, an attacker might succeed in authentication by providing a small password that matches the associated portion of the larger, correct password.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-1023\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is conceptually similar to other weaknesses, such as insufficient verification and regular expression errors. It is primary to some weaknesses.\n\n\n\n### Observed Examples\n- **CVE-2014-6394:** Product does not prevent access to restricted directories due to partial string comparison with a public directory\n- **CVE-2004-1012:** Argument parser of an IMAP server treats a partial command \"body[p\" as if it is \"body.peek\", leading to index error and out-of-bounds corruption.\n- **CVE-2004-0765:** Web browser only checks the hostname portion of a certificate when the hostname portion of the URI is not a fully qualified domain name (FQDN), which allows remote attackers to spoof trusted certificates.\n\n\n\n\n## CWE-674: Uncontrolled Recursion\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion\n\n### Relationships\nChildOf -> CWE-834\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2007-1285:** Deeply nested arrays trigger stack exhaustion.\n- **CVE-2007-3409:** Self-referencing pointers create infinite loop and resultant stack exhaustion.\n- **CVE-2016-10707:** Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.\n\n\n\n\n## CWE-617: Reachable Assertion\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.\n\n### Extended Description\n\n\nWhile assertion is good for catching logic errors and reducing the chances of reaching more serious vulnerability conditions, it can still lead to a denial of service.\n\n\nFor example, if a server handles multiple simultaneous connections, and an assert() occurs in one single connection that causes all other connections to be dropped, this is a reachable assertion that leads to a denial of service.\n\n\n### Alternative Terms\nassertion failure\n\n### Relationships\nChildOf -> CWE-670\nChildOf -> CWE-670\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2006-6767:** FTP server allows remote attackers to cause a denial of service (daemon abort) via crafted commands which trigger an assertion failure.\n- **CVE-2006-6811:** Chat client allows remote attackers to cause a denial of service (crash) via a long message string when connecting to a server, which causes an assertion failure.\n\n\n\n\n## CWE-626: Null Byte Interaction Error (Poison Null Byte)\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not properly handle null bytes or NUL characters when passing data between different representations or components.\n\n### Extended Description\n\n\nA null byte (NUL character) can have different meanings across representations or languages. For example, it is a string terminator in standard C libraries, but Perl and PHP strings do not treat it as a terminator. When two representations are crossed - such as when Perl or PHP invokes underlying C functionality - this can produce an interaction error with unexpected results. Similar issues have been reported for ASP. Other interpreters written in C might also be affected.\n\n\nThe poison null byte is frequently useful in path traversal attacks by terminating hard-coded extensions that are added to a filename. It can play a role in regular expression processing in PHP.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-147\nChildOf -> CWE-436\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** Current usage of \"poison null byte\" is typically related to this C/Perl/PHP interaction error, but the original term in 1998 was applied to an off-by-one buffer overflow involving a null byte.\n\n**[Research Gap]** There are not many CVE examples, because the poison NULL byte is a design limitation, which typically is not included in CVE by itself. It is typically used as a facilitator manipulation to widen the scope of potential attacks against other vulnerabilities.\n\n\n\n### Observed Examples\n- **CVE-2005-4155:** NUL byte bypasses PHP regular expression check\n- **CVE-2005-3153:** inserting SQL after a NUL byte bypasses allowlist regexp, enabling SQL injection\n\n"
  },
  "timestamp": "2025-03-31 06:31:11",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "212",
      "name": "Improper Removal of Sensitive Information Before Storage or Transfer",
      "type": "Base",
      "score": 0.7579740497485008
    },
    {
      "cwe_id": "74",
      "name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')",
      "type": "Class",
      "score": 0.7558023657949366
    },
    {
      "cwe_id": "158",
      "name": "Improper Neutralization of Null Byte or NUL Character",
      "type": "Variant",
      "score": 0.7549872114619955
    },
    {
      "cwe_id": "703",
      "name": "Improper Check or Handling of Exceptional Conditions",
      "type": "Pillar",
      "score": 0.7547298670272735
    },
    {
      "cwe_id": "184",
      "name": "Incomplete List of Disallowed Inputs",
      "type": "Base",
      "score": 0.7541594295665668
    },
    {
      "cwe_id": "1289",
      "name": "Improper Validation of Unsafe Equivalence in Input",
      "type": "Base",
      "score": 0.7537176320809825
    },
    {
      "cwe_id": "754",
      "name": "Improper Check for Unusual or Exceptional Conditions",
      "type": "Class",
      "score": 0.7535307560476712
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "type": "Base",
      "score": 0.7529542457177743
    },
    {
      "cwe_id": "138",
      "name": "Improper Neutralization of Special Elements",
      "type": "Class",
      "score": 0.7525156877344075
    },
    {
      "cwe_id": "755",
      "name": "Improper Handling of Exceptional Conditions",
      "type": "Class",
      "score": 0.7519452321377311
    }
  ]
}