{
  "retriever": "dense",
  "query": "## Vulnerability Description\nA **stack overflow** vulnerability exists in the httpd service in ASUS RT-AX56U Router Version 3.0.0.4.386.44266. This vulnerability is caused by the **strcat function called by caupload input handle function allowing the user to enter 0xFFFF bytes into the stack**. This vulnerability allows an attacker to execute commands remotely. The vulnerability requires authentication.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **strcat function called by caupload input handle function allowing the user to enter 0xFFFF bytes into the stack**\n- **weakness:** **stack overflow**\n- **impact:** execute commands remotely\n- **product:** ASUS RT-AX56U Router\n- **version:** Version 3.0.0.4.386.44266\n- **component:** httpd service\n\n## CVE Reference Links Content Summary\nThe provided content discusses a stack overflow vulnerability in the ASUS RT-AX56U router's httpd service, identified as CVE-2021-40556.\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from a stack buffer overflow within the `caupload.cgi` handler's input function in the httpd service. This occurs when the `strcat` function appends data from the HTTP request to a stack-allocated buffer without proper bounds checking.\n\n**Weaknesses/Vulnerabilities:**\n- Stack buffer overflow: The `strcat` function copies data of an attacker-controlled size onto a fixed-size stack buffer, leading to the overwrite of stack memory.\n- Lack of input validation: The Content-Length is not properly validated against the stack buffer size.\n- Missing canaries: No stack canaries are used to detect buffer overflows, which could crash the program and make exploitation harder\n\n**Impact of Exploitation:**\n- Remote Code Execution (RCE): The attacker can gain arbitrary code execution by overwriting return addresses on the stack. The article shows how to achieve RCE by redirecting execution to a gadget that calls system() and controlling the arguments.\n\n**Attack Vectors:**\n- HTTP request: The vulnerability is triggered by sending a crafted HTTP POST request to the `caupload.cgi` endpoint, specifically by manipulating the \"Content-Disposition: form-data; name=\"file_ca\"; filename=\" field to send a large amount of data.\n\n**Required Attacker Capabilities/Position:**\n- Network access: The attacker needs to be able to send HTTP requests to the router's web interface. The attacker does not need to be on the same LAN, making it possible to attack it remotely if the HTTP service is exposed to the internet\n- Authentication: The attacker must authenticate to the web interface before exploiting the vulnerability. The provided exploit uses the login endpoint to obtain the necessary cookie\n- Understanding of HTTP protocol: The attacker needs to know the structure of HTTP requests and how to manipulate them.\n\n**Additional Details:**\n- The vulnerability is located in the `input` function of the `caupload.cgi` handler.\n- The `strcat` function is used to append user-provided data to a stack buffer without proper bounds checks.\n- The exploit detailed involves overwriting the return address on the stack to redirect execution to an existing code gadget within the httpd service, which calls the `doSystem` function, which is a wrapper for `system()`, allowing the attacker to execute arbitrary system commands\n- The attacker crafts a special request that injects the malicious command into the cookie value, where the `doSystem` function will then execute it.\n- The router's httpd service is running as a non-PIE binary, making ROP attacks more feasible\n- The vulnerability affects multiple ASUS router models.\n- The exploit leverages a code gadget to call the `doSystem` function with a user controlled argument taken from the cookie, and avoids dealing with \\x00 bytes in the return address.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 121 | Stack-based Buffer Overflow | Variant | Allowed | alternate_terms | 1.000 |\n| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |\n| 3 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.376 |\n| 4 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.372 |\n| 5 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.365 |\n| 6 | 78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | dense | 0.573 |\n| 7 | 128 | Wrap-around Error | Base | Allowed | graph | 0.002 |\n| 8 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | sparse | 0.365 |\n| 9 | 457 | Use of Uninitialized Variable | Variant | Allowed | sparse | 0.361 |\n| 10 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.361 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n\n\n\n## CWE-789: Memory Allocation with Excessive Size Value\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.\n\n### Relationships\nChildOf -> CWE-770\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.\n\n**[Applicable Platform]** \n\nUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\n\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2010-3701:** program uses ::alloca() for encoding messages, but large messages trigger segfault\n- **CVE-2008-1708:** memory consumption and daemon exit by specifying a large value in a length field\n\n\n\n\n## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n### Extended Description\n\n\nThis weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.\n\n\nThere are at least two subtypes of OS command injection:\n\n\n  - The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.\n\n  - The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.\n\nFrom a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.\n\n### Alternative Terms\nShell injection\nShell metacharacters\nOS Command Injection\n\n### Relationships\nChildOf -> CWE-77\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\nCanAlsoBe -> CWE-88\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** The \"OS command injection\" phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an \"-exec\" switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX \"find\" command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.\n\n**[Research Gap]** More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.\n\n\n\n### Observed Examples\n- **CVE-2020-10987:** OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.\n- **CVE-2020-10221:** Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.\n- **CVE-2020-9054:** Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-128: Wrap-around Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nWrap around errors occur whenever a value is incremented past the maximum value for its type and therefore \"wraps around\" to a very small, negative, or undefined value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nCanPrecede -> CWE-119\nPeerOf -> CWE-190\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** The relationship between overflow and wrap-around needs to be examined more closely, since several entries (including CWE-190) are closely related.\n\n\n\n\n\n\n## CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.\n\n### Extended Description\nA buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the \"classic\" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.\n\n### Alternative Terms\nClassic Buffer Overflow: This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques.\nUnbounded Transfer\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** There are some indications that this CWE ID might be misused and selected simply because it mentions \"buffer overflow\" - an increasingly vague term. This CWE entry is only appropriate for \"Buffer Copy\" operations (not buffer reads), in which where there is no \"Checking [the] Size of Input\", and (by implication of the copy) writing past the end of the buffer.\n**Comments:** If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Relationship]** At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them.\n\n**[Terminology]** Many issues that are now called \"buffer overflows\" are substantively different than the \"classic\" overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported.\n\n\n\n### Observed Examples\n- **CVE-2000-1094:** buffer overflow using command with long argument\n- **CVE-1999-0046:** buffer overflow in local program using long environment variable\n- **CVE-2002-1337:** buffer overflow in comment characters, when product increments a counter for a \">\" but does not decrement for \"<\"\n\n\n\n\n## CWE-457: Use of Uninitialized Variable\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe code uses a variable that has not been initialized, leading to unpredictable or unintended results.\n\n### Extended Description\nIn some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-908\nChildOf -> CWE-665\nChildOf -> CWE-665\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2019-15900:** Chain: sscanf() call is used to check if a username and group exists, but the return value of sscanf() call is not checked (CWE-252), causing an uninitialized variable to be checked (CWE-457), returning success to allow authorization bypass for executing a privileged (CWE-863).\n- **CVE-2008-3688:** Chain: A denial of service may be caused by an uninitialized variable (CWE-457) allowing an infinite loop (CWE-835) resulting from a connection to an unresponsive server.\n- **CVE-2008-0081:** Uninitialized variable leads to code execution in popular desktop application.\n\n\n\n\n## CWE-674: Uncontrolled Recursion\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion\n\n### Relationships\nChildOf -> CWE-834\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2007-1285:** Deeply nested arrays trigger stack exhaustion.\n- **CVE-2007-3409:** Self-referencing pointers create infinite loop and resultant stack exhaustion.\n- **CVE-2016-10707:** Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.\n\n",
  "keyphrases": {},
  "timestamp": "2025-03-31 04:12:57",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "1325",
      "name": "Improperly Controlled Sequential Memory Allocation",
      "type": "Base",
      "score": 0.751046926953181
    },
    {
      "cwe_id": "674",
      "name": "Uncontrolled Recursion",
      "type": "Class",
      "score": 0.7472595317842917
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.7296471990558611
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 0.7292597705446657
    },
    {
      "cwe_id": "789",
      "name": "Memory Allocation with Excessive Size Value",
      "type": "Variant",
      "score": 0.7267431262154549
    },
    {
      "cwe_id": "691",
      "name": "Insufficient Control Flow Management",
      "type": "Pillar",
      "score": 0.7262204185248669
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "Base",
      "score": 0.7241691871444085
    },
    {
      "cwe_id": "41",
      "name": "Improper Resolution of Path Equivalence",
      "type": "Base",
      "score": 0.7236556796860507
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "type": "Class",
      "score": 0.7230856057531599
    },
    {
      "cwe_id": "664",
      "name": "Improper Control of a Resource Through its Lifetime",
      "type": "Pillar",
      "score": 0.719554498565396
    }
  ]
}