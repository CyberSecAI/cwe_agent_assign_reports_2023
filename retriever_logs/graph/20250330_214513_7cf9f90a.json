{
  "retriever": "graph",
  "query": "## Vulnerability Description\nAn **Improper Control of a Resource Through its Lifetime** vulnerability in the Packet Forwarding Engine (PFE) of Juniper Networks Junos OS on MX Series allows an unauthenticated adjacent attacker to cause a Denial of Service (DoS). When there is a continuous mac move a **memory corruption** causes one or more FPCs to crash and reboot. These MAC moves can be between two local interfaces or between core/EVPN and local interface. The below error logs can be seen in PFE syslog when this issue happens xss_event_handler(1071) EA[00]_PPE 46.xss[0] ADDR Error. ppe_error_interrupt(4298) EA[00]_PPE 46 Errors sync xtxn error xss_event_handler(1071) EA[00]_PPE 1.xss[0] ADDR Error. ppe_error_interrupt(4298) EA[00]_PPE 1 Errors sync xtxn error xss_event_handler(1071) EA[00]_PPE 2.xss[0] ADDR Error. This issue affects Juniper Networks Junos OS on MX Series All versions prior to 15.1R7-S13 19.1 versions prior to 19.1R3-S9 19.2 versions prior to 19.2R3-S6 19.3 versions prior to 19.3R3-S6 19.4 versions prior to 19.4R2-S7, 19.4R3-S8 20.1 version 20.1R1 and later versions 20.2 versions prior to 20.2R3-S5 20.3 versions prior to 20.3R3-S5 20.4 versions prior to 20.4R3-S2 21.1 versions prior to 21.1R3 21.2 versions prior to 21.2R3 21.3 versions prior to 21.3R2.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **Improper Control of a Resource Through its Lifetime**\n- **weakness:** **memory corruption**\n- **impact:** denial of service\n- **vector:** continuous mac move\n- **attacker:** unauthenticated adjacent attacker\n- **product:** Juniper Networks Junos OS on MX Series\n- **version:** All versions prior to 15.1R7-S13 and 19.1 versions prior to 19.1R3-S9 and 19.2 versions prior to 19.2R3-S6 and 19.3 versions prior to 19.3R3-S6 and 19.4 versions prior to 19.4R2-S7 and 19.4R3-S8 and 20.1 version 20.1R1 and later versions and 20.2 versions prior to 20.2R3-S5 and 20.3 versions prior to 20.3R3-S5 and 20.4 versions prior to 20.4R3-S2 and 21.1 versions prior to 21.1R3 and 21.2 versions prior to 21.2R3 and 21.3 versions prior to 21.3R2\n- **component:** Packet Forwarding Engine (PFE) of Juniper Networks Junos OS\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 787 | Out-of-bounds Write | Base | Allowed | alternate_terms | 1.000 |\n| 2 | 664 | Improper Control of a Resource Through its Lifetime | Pillar | Discouraged | sparse | 3.056 |\n| 3 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 1.530 |\n| 4 | 1250 | Improper Preservation of Consistency Between Independent Representations of Shared State | Base | Allowed | sparse | 1.504 |\n| 5 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 1.502 |\n| 6 | 410 | Insufficient Resource Pool | Base | Allowed | dense | 0.657 |\n| 7 | 390 | Detection of Error Condition Without Action | Base | Allowed | graph | 0.002 |\n| 8 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 1.477 |\n| 9 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | sparse | 1.418 |\n| 10 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 1.407 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-787: Out-of-bounds Write\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product writes data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMemory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.\n- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.\n- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-664: Improper Control of a Resource Through its Lifetime\n**Abstraction:** Pillar\n**Status:** Draft\n\n### Description\nThe product does not maintain or incorrectly maintains control over a resource throughout its lifetime of creation, use, and release.\n\n### Extended Description\n\n\nResources often have explicit instructions on how to be created, used and destroyed. When code does not follow these instructions, it can lead to unexpected behaviors and potentially exploitable states.\n\n\nEven without explicit instructions, various principles are expected to be adhered to, such as \"Do not use an object until after its creation is complete,\" or \"do not use an object after it has been slated for destruction.\"\n\n\n### Alternative Terms\nNone\n\n### Relationships\nNone\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is high-level when lower-level children are available.\n**Comments:** Consider children or descendants of this entry instead.\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** More work is needed on this entry and its children. There are perspective/layering issues; for example, one breakdown is based on lifecycle phase (CWE-404, CWE-665), while other children are independent of lifecycle, such as CWE-400. Others do not specify as many bases or variants, such as CWE-704, which primarily covers numbers at this stage.\n\n\n\n### Observed Examples\n- **CVE-2018-1000613:** Cryptography API uses unsafe reflection when deserializing a private key\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n\n\n\n## CWE-401: Missing Release of Memory after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.\n\n### Extended Description\nThis is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.\n\n### Alternative Terms\nMemory Leak\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is often a resultant weakness due to improper handling of malformed data or early termination of sessions.\n\n**[Terminology]** \"memory leak\" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict).\n\n\n\n### Observed Examples\n- **CVE-2005-3119:** Memory leak because function does not free() an element of a data structure.\n- **CVE-2004-0427:** Memory leak when counter variable is not decremented.\n- **CVE-2002-0574:** chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.\n\n\n\n\n## CWE-1250: Improper Preservation of Consistency Between Independent Representations of Shared State\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product has or supports multiple distributed components or sub-systems that are each required to keep their own local copy of shared data - such as state or cache - but the product does not ensure that all local copies remain consistent with each other.\n\n### Extended Description\n\n\nIn highly distributed environments, or on systems with distinct physical components that operate independently, there is often a need for each component to store and update its own local copy of key data such as state or cache, so that all components have the same \"view\" of the overall system and operate in a coordinated fashion. For example, users of a social media service or a massively multiplayer online game might be using their own personal computers while also interacting with different physical hosts in a globally distributed service, but all participants must be able to have the same \"view\" of the world. Alternately, a processor's Memory Management Unit (MMU) might have \"shadow\" MMUs to distribute its workload, and all shadow MMUs are expected to have the same accessible ranges of memory.\n\n\nIn such environments, it becomes critical for the product to ensure that this \"shared state\" is consistently modified across all distributed systems. If state is not consistently maintained across all systems, then critical transactions might take place out of order, or some users might not get the same data as other users. When this inconsistency affects correctness of operations, it can introduce vulnerabilities in mechanisms that depend on consistent state.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** Issues related to state and cache - creation, preservation, and update - are a significant gap in CWE that is expected to be addressed in future versions. It likely has relationships to concurrency and synchronization, incorrect behavior order, and other areas that already have some coverage in CWE, although the focus has typically been on independent processes on the same operating system - not on independent systems that are all a part of a larger system-of-systems.\n\n\n\n\n\n\n## CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify an index, position, or offset into an indexable resource such as a buffer or file, but it does not validate or incorrectly validates that the specified index/position/offset has the required properties.\n\n### Extended Description\n\n\nOften, indexable resources such as memory buffers or files can be accessed using a specific position, index, or offset, such as an index for an array or a position for a file. When untrusted input is not properly validated before it is used as an index, attackers could access (or attempt to access) unauthorized portions of these resources. This could be used to cause buffer overflows, excessive resource allocation, or trigger unexpected failures. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2005-0369:** large ID in packet used as array index\n- **CVE-2001-1009:** negative array index as argument to POP LIST command\n\n\n\n\n## CWE-410: Insufficient Resource Pool\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product's resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.\n\n### Extended Description\nFrequently the consequence is a \"flood\" of connection or sessions.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\nCanPrecede -> CWE-400\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-1999-1363:** Large number of locks on file exhausts the pool and causes crash.\n- **CVE-2001-1340:** Product supports only one connection and does not disconnect a user who does not provide credentials.\n- **CVE-2002-0406:** Large number of connections without providing credentials allows connection exhaustion.\n\n\n\n\n## CWE-390: Detection of Error Condition Without Action\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product detects a specific error, but takes no actions to handle the error.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-755\nCanPrecede -> CWE-401\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-21820:** A GPU data center manager detects an error due to a malformed request but does not act on it, leading to memory corruption.\n\n\n\n\n## CWE-754: Improper Check for Unusual or Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.\n\n### Extended Description\n\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\nCanPrecede -> CWE-416\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.\n- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.\n\n\n\n\n## CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.\n\n### Extended Description\nWhen a file descriptor or handle is not released after use (typically by explicitly closing it), attackers can cause a denial of service by consuming all available file descriptors/handles, or otherwise preventing other system processes from obtaining their own file descriptors/handles.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2007-0897:** Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.\n\n\n\n\n## CWE-400: Uncontrolled Resource Consumption\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.\n\n### Extended Description\n\n\nLimited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the product, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system.\n\n\nThere are at least three distinct scenarios which can commonly lead to resource exhaustion:\n\n\n  - Lack of throttling for the number of allocated resources\n\n  - Losing all references to a resource before reaching the shutdown stage\n\n  - Not closing/returning a resource after processing\n\nResource exhaustion problems are often result due to an incorrect implementation of the following situations:\n\n  - Error conditions and other exceptional circumstances.\n\n  - Confusion over which part of the program is responsible for releasing the resource.\n\n\n\n### Alternative Terms\nResource Exhaustion\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-400 is intended for incorrect behaviors in which the product is expected to track and restrict how many resources it consumes, but CWE-400 is often misused because it is conflated with the \"technical impact\" of vulnerabilities in which resource consumption occurs. It is sometimes used for low-information vulnerability reports. It is a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Closely analyze the specific mistake that is causing resource consumption, and perform a CWE mapping for that mistake. Consider children/descendants such as CWE-770: Allocation of Resources Without Limits or Throttling, CWE-771: Missing Reference to Active Allocated Resource, CWE-410: Insufficient Resource Pool, CWE-772: Missing Release of Resource after Effective Lifetime, CWE-834: Excessive Iteration, CWE-405: Asymmetric Resource Consumption (Amplification), and others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Maintenance]** \"Resource consumption\" could be interpreted as a consequence instead of an insecure behavior, so this entry is being considered for modification. It appears to be referenced too frequently when more precise mappings are available. Some of its children, such as CWE-771, might be better considered as a chain.\n\n**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect the underlying weaknesses that enable these attacks (or consequences) to take place.\n\n**[Other]** \n\nDatabase queries that take a long time to process are good DoS targets. An attacker would have to write a few lines of Perl code to generate enough traffic to exceed the site's ability to keep up. This would effectively prevent authorized users from using the site at all. Resources can be exploited simply by ensuring that the target machine must do much more work and consume more resources in order to service a request than the attacker must do to initiate a request.\n\n\nA prime example of this can be found in old switches that were vulnerable to \"macof\" attacks (so named for a tool developed by Dugsong). These attacks flooded a switch with random IP and MAC address combinations, therefore exhausting the switch's cache, which held the information of which port corresponded to which MAC addresses. Once this cache was exhausted, the switch would fail in an insecure way and would begin to act simply as a hub, broadcasting all traffic on all ports and allowing for basic sniffing attacks.\n\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2020-7218:** Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service\n- **CVE-2020-3566:** Resource exhaustion in distributed OS because of \"insufficient\" IGMP queue management, as exploited in the wild per CISA KEV.\n\n Consider specifically these CWEs: CWE-405 CWE-1250 CWE-401 CWE-754 CWE-404 CWE-772 CWE-226 CWE-770 CWE-664",
  "keyphrases": {
    "original_query": "## Vulnerability Description\nAn **Improper Control of a Resource Through its Lifetime** vulnerability in the Packet Forwarding Engine (PFE) of Juniper Networks Junos OS on MX Series allows an unauthenticated adjacent attacker to cause a Denial of Service (DoS). When there is a continuous mac move a **memory corruption** causes one or more FPCs to crash and reboot. These MAC moves can be between two local interfaces or between core/EVPN and local interface. The below error logs can be seen in PFE syslog when this issue happens xss_event_handler(1071) EA[00]_PPE 46.xss[0] ADDR Error. ppe_error_interrupt(4298) EA[00]_PPE 46 Errors sync xtxn error xss_event_handler(1071) EA[00]_PPE 1.xss[0] ADDR Error. ppe_error_interrupt(4298) EA[00]_PPE 1 Errors sync xtxn error xss_event_handler(1071) EA[00]_PPE 2.xss[0] ADDR Error. This issue affects Juniper Networks Junos OS on MX Series All versions prior to 15.1R7-S13 19.1 versions prior to 19.1R3-S9 19.2 versions prior to 19.2R3-S6 19.3 versions prior to 19.3R3-S6 19.4 versions prior to 19.4R2-S7, 19.4R3-S8 20.1 version 20.1R1 and later versions 20.2 versions prior to 20.2R3-S5 20.3 versions prior to 20.3R3-S5 20.4 versions prior to 20.4R3-S2 21.1 versions prior to 21.1R3 21.2 versions prior to 21.2R3 21.3 versions prior to 21.3R2.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **Improper Control of a Resource Through its Lifetime**\n- **weakness:** **memory corruption**\n- **impact:** denial of service\n- **vector:** continuous mac move\n- **attacker:** unauthenticated adjacent attacker\n- **product:** Juniper Networks Junos OS on MX Series\n- **version:** All versions prior to 15.1R7-S13 and 19.1 versions prior to 19.1R3-S9 and 19.2 versions prior to 19.2R3-S6 and 19.3 versions prior to 19.3R3-S6 and 19.4 versions prior to 19.4R2-S7 and 19.4R3-S8 and 20.1 version 20.1R1 and later versions and 20.2 versions prior to 20.2R3-S5 and 20.3 versions prior to 20.3R3-S5 and 20.4 versions prior to 20.4R3-S2 and 21.1 versions prior to 21.1R3 and 21.2 versions prior to 21.2R3 and 21.3 versions prior to 21.3R2\n- **component:** Packet Forwarding Engine (PFE) of Juniper Networks Junos OS\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 787 | Out-of-bounds Write | Base | Allowed | alternate_terms | 1.000 |\n| 2 | 664 | Improper Control of a Resource Through its Lifetime | Pillar | Discouraged | sparse | 3.056 |\n| 3 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 1.530 |\n| 4 | 1250 | Improper Preservation of Consistency Between Independent Representations of Shared State | Base | Allowed | sparse | 1.504 |\n| 5 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 1.502 |\n| 6 | 410 | Insufficient Resource Pool | Base | Allowed | dense | 0.657 |\n| 7 | 390 | Detection of Error Condition Without Action | Base | Allowed | graph | 0.002 |\n| 8 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 1.477 |\n| 9 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | sparse | 1.418 |\n| 10 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 1.407 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-787: Out-of-bounds Write\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product writes data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMemory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.\n- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.\n- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-664: Improper Control of a Resource Through its Lifetime\n**Abstraction:** Pillar\n**Status:** Draft\n\n### Description\nThe product does not maintain or incorrectly maintains control over a resource throughout its lifetime of creation, use, and release.\n\n### Extended Description\n\n\nResources often have explicit instructions on how to be created, used and destroyed. When code does not follow these instructions, it can lead to unexpected behaviors and potentially exploitable states.\n\n\nEven without explicit instructions, various principles are expected to be adhered to, such as \"Do not use an object until after its creation is complete,\" or \"do not use an object after it has been slated for destruction.\"\n\n\n### Alternative Terms\nNone\n\n### Relationships\nNone\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is high-level when lower-level children are available.\n**Comments:** Consider children or descendants of this entry instead.\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** More work is needed on this entry and its children. There are perspective/layering issues; for example, one breakdown is based on lifecycle phase (CWE-404, CWE-665), while other children are independent of lifecycle, such as CWE-400. Others do not specify as many bases or variants, such as CWE-704, which primarily covers numbers at this stage.\n\n\n\n### Observed Examples\n- **CVE-2018-1000613:** Cryptography API uses unsafe reflection when deserializing a private key\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n\n\n\n## CWE-401: Missing Release of Memory after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.\n\n### Extended Description\nThis is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.\n\n### Alternative Terms\nMemory Leak\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is often a resultant weakness due to improper handling of malformed data or early termination of sessions.\n\n**[Terminology]** \"memory leak\" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict).\n\n\n\n### Observed Examples\n- **CVE-2005-3119:** Memory leak because function does not free() an element of a data structure.\n- **CVE-2004-0427:** Memory leak when counter variable is not decremented.\n- **CVE-2002-0574:** chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.\n\n\n\n\n## CWE-1250: Improper Preservation of Consistency Between Independent Representations of Shared State\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product has or supports multiple distributed components or sub-systems that are each required to keep their own local copy of shared data - such as state or cache - but the product does not ensure that all local copies remain consistent with each other.\n\n### Extended Description\n\n\nIn highly distributed environments, or on systems with distinct physical components that operate independently, there is often a need for each component to store and update its own local copy of key data such as state or cache, so that all components have the same \"view\" of the overall system and operate in a coordinated fashion. For example, users of a social media service or a massively multiplayer online game might be using their own personal computers while also interacting with different physical hosts in a globally distributed service, but all participants must be able to have the same \"view\" of the world. Alternately, a processor's Memory Management Unit (MMU) might have \"shadow\" MMUs to distribute its workload, and all shadow MMUs are expected to have the same accessible ranges of memory.\n\n\nIn such environments, it becomes critical for the product to ensure that this \"shared state\" is consistently modified across all distributed systems. If state is not consistently maintained across all systems, then critical transactions might take place out of order, or some users might not get the same data as other users. When this inconsistency affects correctness of operations, it can introduce vulnerabilities in mechanisms that depend on consistent state.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** Issues related to state and cache - creation, preservation, and update - are a significant gap in CWE that is expected to be addressed in future versions. It likely has relationships to concurrency and synchronization, incorrect behavior order, and other areas that already have some coverage in CWE, although the focus has typically been on independent processes on the same operating system - not on independent systems that are all a part of a larger system-of-systems.\n\n\n\n\n\n\n## CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify an index, position, or offset into an indexable resource such as a buffer or file, but it does not validate or incorrectly validates that the specified index/position/offset has the required properties.\n\n### Extended Description\n\n\nOften, indexable resources such as memory buffers or files can be accessed using a specific position, index, or offset, such as an index for an array or a position for a file. When untrusted input is not properly validated before it is used as an index, attackers could access (or attempt to access) unauthorized portions of these resources. This could be used to cause buffer overflows, excessive resource allocation, or trigger unexpected failures. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2005-0369:** large ID in packet used as array index\n- **CVE-2001-1009:** negative array index as argument to POP LIST command\n\n\n\n\n## CWE-410: Insufficient Resource Pool\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product's resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.\n\n### Extended Description\nFrequently the consequence is a \"flood\" of connection or sessions.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\nCanPrecede -> CWE-400\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-1999-1363:** Large number of locks on file exhausts the pool and causes crash.\n- **CVE-2001-1340:** Product supports only one connection and does not disconnect a user who does not provide credentials.\n- **CVE-2002-0406:** Large number of connections without providing credentials allows connection exhaustion.\n\n\n\n\n## CWE-390: Detection of Error Condition Without Action\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product detects a specific error, but takes no actions to handle the error.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-755\nCanPrecede -> CWE-401\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-21820:** A GPU data center manager detects an error due to a malformed request but does not act on it, leading to memory corruption.\n\n\n\n\n## CWE-754: Improper Check for Unusual or Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.\n\n### Extended Description\n\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\nCanPrecede -> CWE-416\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.\n- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.\n\n\n\n\n## CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.\n\n### Extended Description\nWhen a file descriptor or handle is not released after use (typically by explicitly closing it), attackers can cause a denial of service by consuming all available file descriptors/handles, or otherwise preventing other system processes from obtaining their own file descriptors/handles.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2007-0897:** Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.\n\n\n\n\n## CWE-400: Uncontrolled Resource Consumption\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.\n\n### Extended Description\n\n\nLimited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the product, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system.\n\n\nThere are at least three distinct scenarios which can commonly lead to resource exhaustion:\n\n\n  - Lack of throttling for the number of allocated resources\n\n  - Losing all references to a resource before reaching the shutdown stage\n\n  - Not closing/returning a resource after processing\n\nResource exhaustion problems are often result due to an incorrect implementation of the following situations:\n\n  - Error conditions and other exceptional circumstances.\n\n  - Confusion over which part of the program is responsible for releasing the resource.\n\n\n\n### Alternative Terms\nResource Exhaustion\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-400 is intended for incorrect behaviors in which the product is expected to track and restrict how many resources it consumes, but CWE-400 is often misused because it is conflated with the \"technical impact\" of vulnerabilities in which resource consumption occurs. It is sometimes used for low-information vulnerability reports. It is a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Closely analyze the specific mistake that is causing resource consumption, and perform a CWE mapping for that mistake. Consider children/descendants such as CWE-770: Allocation of Resources Without Limits or Throttling, CWE-771: Missing Reference to Active Allocated Resource, CWE-410: Insufficient Resource Pool, CWE-772: Missing Release of Resource after Effective Lifetime, CWE-834: Excessive Iteration, CWE-405: Asymmetric Resource Consumption (Amplification), and others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Maintenance]** \"Resource consumption\" could be interpreted as a consequence instead of an insecure behavior, so this entry is being considered for modification. It appears to be referenced too frequently when more precise mappings are available. Some of its children, such as CWE-771, might be better considered as a chain.\n\n**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect the underlying weaknesses that enable these attacks (or consequences) to take place.\n\n**[Other]** \n\nDatabase queries that take a long time to process are good DoS targets. An attacker would have to write a few lines of Perl code to generate enough traffic to exceed the site's ability to keep up. This would effectively prevent authorized users from using the site at all. Resources can be exploited simply by ensuring that the target machine must do much more work and consume more resources in order to service a request than the attacker must do to initiate a request.\n\n\nA prime example of this can be found in old switches that were vulnerable to \"macof\" attacks (so named for a tool developed by Dugsong). These attacks flooded a switch with random IP and MAC address combinations, therefore exhausting the switch's cache, which held the information of which port corresponded to which MAC addresses. Once this cache was exhausted, the switch would fail in an insecure way and would begin to act simply as a hub, broadcasting all traffic on all ports and allowing for basic sniffing attacks.\n\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2020-7218:** Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service\n- **CVE-2020-3566:** Resource exhaustion in distributed OS because of \"insufficient\" IGMP queue management, as exploited in the wild per CISA KEV.\n\n",
    "enhanced_query": "## Vulnerability Description\nAn **Improper Control of a Resource Through its Lifetime** vulnerability in the Packet Forwarding Engine (PFE) of Juniper Networks Junos OS on MX Series allows an unauthenticated adjacent attacker to cause a Denial of Service (DoS). When there is a continuous mac move a **memory corruption** causes one or more FPCs to crash and reboot. These MAC moves can be between two local interfaces or between core/EVPN and local interface. The below error logs can be seen in PFE syslog when this issue happens xss_event_handler(1071) EA[00]_PPE 46.xss[0] ADDR Error. ppe_error_interrupt(4298) EA[00]_PPE 46 Errors sync xtxn error xss_event_handler(1071) EA[00]_PPE 1.xss[0] ADDR Error. ppe_error_interrupt(4298) EA[00]_PPE 1 Errors sync xtxn error xss_event_handler(1071) EA[00]_PPE 2.xss[0] ADDR Error. This issue affects Juniper Networks Junos OS on MX Series All versions prior to 15.1R7-S13 19.1 versions prior to 19.1R3-S9 19.2 versions prior to 19.2R3-S6 19.3 versions prior to 19.3R3-S6 19.4 versions prior to 19.4R2-S7, 19.4R3-S8 20.1 version 20.1R1 and later versions 20.2 versions prior to 20.2R3-S5 20.3 versions prior to 20.3R3-S5 20.4 versions prior to 20.4R3-S2 21.1 versions prior to 21.1R3 21.2 versions prior to 21.2R3 21.3 versions prior to 21.3R2.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **Improper Control of a Resource Through its Lifetime**\n- **weakness:** **memory corruption**\n- **impact:** denial of service\n- **vector:** continuous mac move\n- **attacker:** unauthenticated adjacent attacker\n- **product:** Juniper Networks Junos OS on MX Series\n- **version:** All versions prior to 15.1R7-S13 and 19.1 versions prior to 19.1R3-S9 and 19.2 versions prior to 19.2R3-S6 and 19.3 versions prior to 19.3R3-S6 and 19.4 versions prior to 19.4R2-S7 and 19.4R3-S8 and 20.1 version 20.1R1 and later versions and 20.2 versions prior to 20.2R3-S5 and 20.3 versions prior to 20.3R3-S5 and 20.4 versions prior to 20.4R3-S2 and 21.1 versions prior to 21.1R3 and 21.2 versions prior to 21.2R3 and 21.3 versions prior to 21.3R2\n- **component:** Packet Forwarding Engine (PFE) of Juniper Networks Junos OS\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 787 | Out-of-bounds Write | Base | Allowed | alternate_terms | 1.000 |\n| 2 | 664 | Improper Control of a Resource Through its Lifetime | Pillar | Discouraged | sparse | 3.056 |\n| 3 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 1.530 |\n| 4 | 1250 | Improper Preservation of Consistency Between Independent Representations of Shared State | Base | Allowed | sparse | 1.504 |\n| 5 | 1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | sparse | 1.502 |\n| 6 | 410 | Insufficient Resource Pool | Base | Allowed | dense | 0.657 |\n| 7 | 390 | Detection of Error Condition Without Action | Base | Allowed | graph | 0.002 |\n| 8 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 1.477 |\n| 9 | 775 | Missing Release of File Descriptor or Handle after Effective Lifetime | Variant | Allowed | sparse | 1.418 |\n| 10 | 400 | Uncontrolled Resource Consumption | Class | Discouraged | sparse | 1.407 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-787: Out-of-bounds Write\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product writes data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMemory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.\n- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.\n- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-664: Improper Control of a Resource Through its Lifetime\n**Abstraction:** Pillar\n**Status:** Draft\n\n### Description\nThe product does not maintain or incorrectly maintains control over a resource throughout its lifetime of creation, use, and release.\n\n### Extended Description\n\n\nResources often have explicit instructions on how to be created, used and destroyed. When code does not follow these instructions, it can lead to unexpected behaviors and potentially exploitable states.\n\n\nEven without explicit instructions, various principles are expected to be adhered to, such as \"Do not use an object until after its creation is complete,\" or \"do not use an object after it has been slated for destruction.\"\n\n\n### Alternative Terms\nNone\n\n### Relationships\nNone\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is high-level when lower-level children are available.\n**Comments:** Consider children or descendants of this entry instead.\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** More work is needed on this entry and its children. There are perspective/layering issues; for example, one breakdown is based on lifecycle phase (CWE-404, CWE-665), while other children are independent of lifecycle, such as CWE-400. Others do not specify as many bases or variants, such as CWE-704, which primarily covers numbers at this stage.\n\n\n\n### Observed Examples\n- **CVE-2018-1000613:** Cryptography API uses unsafe reflection when deserializing a private key\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n\n\n\n\n## CWE-401: Missing Release of Memory after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.\n\n### Extended Description\nThis is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.\n\n### Alternative Terms\nMemory Leak\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is often a resultant weakness due to improper handling of malformed data or early termination of sessions.\n\n**[Terminology]** \"memory leak\" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict).\n\n\n\n### Observed Examples\n- **CVE-2005-3119:** Memory leak because function does not free() an element of a data structure.\n- **CVE-2004-0427:** Memory leak when counter variable is not decremented.\n- **CVE-2002-0574:** chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.\n\n\n\n\n## CWE-1250: Improper Preservation of Consistency Between Independent Representations of Shared State\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product has or supports multiple distributed components or sub-systems that are each required to keep their own local copy of shared data - such as state or cache - but the product does not ensure that all local copies remain consistent with each other.\n\n### Extended Description\n\n\nIn highly distributed environments, or on systems with distinct physical components that operate independently, there is often a need for each component to store and update its own local copy of key data such as state or cache, so that all components have the same \"view\" of the overall system and operate in a coordinated fashion. For example, users of a social media service or a massively multiplayer online game might be using their own personal computers while also interacting with different physical hosts in a globally distributed service, but all participants must be able to have the same \"view\" of the world. Alternately, a processor's Memory Management Unit (MMU) might have \"shadow\" MMUs to distribute its workload, and all shadow MMUs are expected to have the same accessible ranges of memory.\n\n\nIn such environments, it becomes critical for the product to ensure that this \"shared state\" is consistently modified across all distributed systems. If state is not consistently maintained across all systems, then critical transactions might take place out of order, or some users might not get the same data as other users. When this inconsistency affects correctness of operations, it can introduce vulnerabilities in mechanisms that depend on consistent state.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** Issues related to state and cache - creation, preservation, and update - are a significant gap in CWE that is expected to be addressed in future versions. It likely has relationships to concurrency and synchronization, incorrect behavior order, and other areas that already have some coverage in CWE, although the focus has typically been on independent processes on the same operating system - not on independent systems that are all a part of a larger system-of-systems.\n\n\n\n\n\n\n## CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify an index, position, or offset into an indexable resource such as a buffer or file, but it does not validate or incorrectly validates that the specified index/position/offset has the required properties.\n\n### Extended Description\n\n\nOften, indexable resources such as memory buffers or files can be accessed using a specific position, index, or offset, such as an index for an array or a position for a file. When untrusted input is not properly validated before it is used as an index, attackers could access (or attempt to access) unauthorized portions of these resources. This could be used to cause buffer overflows, excessive resource allocation, or trigger unexpected failures. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2005-0369:** large ID in packet used as array index\n- **CVE-2001-1009:** negative array index as argument to POP LIST command\n\n\n\n\n## CWE-410: Insufficient Resource Pool\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product's resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.\n\n### Extended Description\nFrequently the consequence is a \"flood\" of connection or sessions.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\nCanPrecede -> CWE-400\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-1999-1363:** Large number of locks on file exhausts the pool and causes crash.\n- **CVE-2001-1340:** Product supports only one connection and does not disconnect a user who does not provide credentials.\n- **CVE-2002-0406:** Large number of connections without providing credentials allows connection exhaustion.\n\n\n\n\n## CWE-390: Detection of Error Condition Without Action\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product detects a specific error, but takes no actions to handle the error.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-755\nCanPrecede -> CWE-401\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-21820:** A GPU data center manager detects an error due to a malformed request but does not act on it, leading to memory corruption.\n\n\n\n\n## CWE-754: Improper Check for Unusual or Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.\n\n### Extended Description\n\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\nCanPrecede -> CWE-416\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.\n- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.\n\n\n\n\n## CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.\n\n### Extended Description\nWhen a file descriptor or handle is not released after use (typically by explicitly closing it), attackers can cause a denial of service by consuming all available file descriptors/handles, or otherwise preventing other system processes from obtaining their own file descriptors/handles.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2007-0897:** Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.\n\n\n\n\n## CWE-400: Uncontrolled Resource Consumption\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.\n\n### Extended Description\n\n\nLimited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the product, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system.\n\n\nThere are at least three distinct scenarios which can commonly lead to resource exhaustion:\n\n\n  - Lack of throttling for the number of allocated resources\n\n  - Losing all references to a resource before reaching the shutdown stage\n\n  - Not closing/returning a resource after processing\n\nResource exhaustion problems are often result due to an incorrect implementation of the following situations:\n\n  - Error conditions and other exceptional circumstances.\n\n  - Confusion over which part of the program is responsible for releasing the resource.\n\n\n\n### Alternative Terms\nResource Exhaustion\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-400 is intended for incorrect behaviors in which the product is expected to track and restrict how many resources it consumes, but CWE-400 is often misused because it is conflated with the \"technical impact\" of vulnerabilities in which resource consumption occurs. It is sometimes used for low-information vulnerability reports. It is a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Closely analyze the specific mistake that is causing resource consumption, and perform a CWE mapping for that mistake. Consider children/descendants such as CWE-770: Allocation of Resources Without Limits or Throttling, CWE-771: Missing Reference to Active Allocated Resource, CWE-410: Insufficient Resource Pool, CWE-772: Missing Release of Resource after Effective Lifetime, CWE-834: Excessive Iteration, CWE-405: Asymmetric Resource Consumption (Amplification), and others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Maintenance]** \"Resource consumption\" could be interpreted as a consequence instead of an insecure behavior, so this entry is being considered for modification. It appears to be referenced too frequently when more precise mappings are available. Some of its children, such as CWE-771, might be better considered as a chain.\n\n**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect the underlying weaknesses that enable these attacks (or consequences) to take place.\n\n**[Other]** \n\nDatabase queries that take a long time to process are good DoS targets. An attacker would have to write a few lines of Perl code to generate enough traffic to exceed the site's ability to keep up. This would effectively prevent authorized users from using the site at all. Resources can be exploited simply by ensuring that the target machine must do much more work and consume more resources in order to service a request than the attacker must do to initiate a request.\n\n\nA prime example of this can be found in old switches that were vulnerable to \"macof\" attacks (so named for a tool developed by Dugsong). These attacks flooded a switch with random IP and MAC address combinations, therefore exhausting the switch's cache, which held the information of which port corresponded to which MAC addresses. Once this cache was exhausted, the switch would fail in an insecure way and would begin to act simply as a hub, broadcasting all traffic on all ports and allowing for basic sniffing attacks.\n\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2020-7218:** Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service\n- **CVE-2020-3566:** Resource exhaustion in distributed OS because of \"insufficient\" IGMP queue management, as exploited in the wild per CISA KEV.\n\n Consider specifically these CWEs: CWE-405 CWE-1250 CWE-401 CWE-754 CWE-404 CWE-772 CWE-226 CWE-770 CWE-664",
    "cwe_mentions": [
      "CWE-405",
      "CWE-1250",
      "CWE-401",
      "CWE-754",
      "CWE-404",
      "CWE-772",
      "CWE-226",
      "CWE-770",
      "CWE-664"
    ],
    "search_time": 3.3083689212799072
  },
  "timestamp": "2025-03-30 21:45:13",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "390",
      "name": "Detection of Error Condition Without Action",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "401",
      "name": "Missing Release of Memory after Effective Lifetime",
      "type": "variant",
      "score": 3.8784,
      "relationship_count": 0
    },
    {
      "cwe_id": "416",
      "name": "Use After Free",
      "type": "variant",
      "score": 3.7507200000000003,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 3.3566,
      "relationship_count": 0
    },
    {
      "cwe_id": "787",
      "name": "Out-of-bounds Write",
      "type": "base",
      "score": 3.1356,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 2.9120000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "1339",
      "name": "Insufficient Precision or Accuracy of a Real Number",
      "type": "base",
      "score": 2.9120000000000004,
      "relationship_count": 0
    },
    {
      "cwe_id": "410",
      "name": "Insufficient Resource Pool",
      "type": "Base",
      "score": 2.904830107283689,
      "relationship_count": 0
    }
  ]
}