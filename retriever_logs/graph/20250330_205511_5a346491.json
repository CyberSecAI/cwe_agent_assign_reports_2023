{
  "retriever": "graph",
  "query": "## Vulnerability Description\nClash for Windows v0.19.8 was discovered to allow arbitrary code execution via a crafted payload injected into the Proxies name column.\n\n### Vulnerability Description Key Phrases\n- **impact:** arbitrary code execution\n- **vector:** crafted payload injected into the Proxies name column\n- **product:** Windows\n- **version:** v0.19.8\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.044 |\n| 2 | 78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | sparse | 0.040 |\n| 3 | 116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | sparse | 0.039 |\n| 4 | 94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | sparse | 0.039 |\n| 5 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.038 |\n| 6 | 941 | Incorrectly Specified Destination in a Communication Channel | Base | Allowed | dense | 0.519 |\n| 7 | 117 | Improper Output Neutralization for Logs | Base | Allowed | graph | 0.003 |\n| 8 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | sparse | 0.037 |\n| 9 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 0.037 |\n| 10 | 93 | Improper Neutralization of CRLF Sequences ('CRLF Injection') | Base | Allowed | sparse | 0.036 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n### Extended Description\n\n\nThis weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.\n\n\nThere are at least two subtypes of OS command injection:\n\n\n  - The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.\n\n  - The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.\n\nFrom a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.\n\n### Alternative Terms\nShell injection\nShell metacharacters\nOS Command Injection\n\n### Relationships\nChildOf -> CWE-77\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\nCanAlsoBe -> CWE-88\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** The \"OS command injection\" phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an \"-exec\" switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX \"find\" command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.\n\n**[Research Gap]** More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.\n\n\n\n### Observed Examples\n- **CVE-2020-10987:** OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.\n- **CVE-2020-10221:** Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.\n- **CVE-2020-9054:** Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-116: Improper Encoding or Escaping of Output\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.\n\n### Extended Description\n\n\nImproper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead.\n\n\nMost products follow a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, \"GET /index.html HTTP/1.1\" is a structured message containing a command (\"GET\") with a single argument (\"/index.html\") and metadata about which protocol version is being used (\"HTTP/1.1\").\n\n\nIf an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.\n\n\n### Alternative Terms\nOutput Sanitization\nOutput Validation\nOutput Encoding\n\n### Relationships\nChildOf -> CWE-707\nCanPrecede -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness is primary to all weaknesses related to injection (CWE-74) since the inherent nature of injection involves the violation of structured messages.\n\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\nHowever, input validation is not always sufficient, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise neutralized. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n**[Terminology]** The usage of the \"encoding\" and \"escaping\" terms varies widely. For example, in some programming languages, the terms are used interchangeably, while other languages provide APIs that use both terms for different tasks. This overlapping usage extends to the Web, such as the \"escape\" JavaScript function whose purpose is stated to be encoding. The concepts of encoding and escaping predate the Web by decades. Given such a context, it is difficult for CWE to adopt a consistent vocabulary that will not be misinterpreted by some constituency.\n\n**[Theoretical]** This is a data/directive boundary error in which data boundaries are not sufficiently enforced before it is sent to a different control sphere.\n\n**[Research Gap]** While many published vulnerabilities are related to insufficient output encoding, there is such an emphasis on input validation as a protection mechanism that the underlying causes are rarely described. Within CVE, the focus is primarily on well-understood issues like cross-site scripting and SQL injection. It is likely that this weakness frequently occurs in custom protocols that support multiple encodings, which are not necessarily detectable with automated techniques.\n\n\n\n### Observed Examples\n- **CVE-2021-41232:** Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90)\n- **CVE-2008-4636:** OS command injection in backup software using shell metacharacters in a filename; correct behavior would require that this filename could not be changed.\n- **CVE-2008-0769:** Web application does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.\n\n\n\n\n## CWE-94: Improper Control of Generation of Code ('Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.\n\n### Extended Description\n\n\nWhen a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution.\n\n\nInjection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nChildOf -> CWE-913\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This entry is frequently misused for vulnerabilities with a technical impact of \"code execution,\" which does not by itself indicate a root cause weakness, since dozens of weaknesses can enable code execution.\n**Comments:** This weakness only applies when the product's functionality intentionally constructs all or part of a code segment. It could be that executing code could be the result of other weaknesses that do not involve the construction of code segments.\n**Reasons:**\n- Frequent Misuse\n- Frequent Misinterpretation\n\n\n\n### Observed Examples\n- **CVE-2023-29374:** Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-5565:** Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-941: Incorrectly Specified Destination in a Communication Channel\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product creates a communication channel to initiate an outgoing request to an actor, but it does not correctly specify the intended destination for that actor.\n\n### Extended Description\n\n\nAttackers at the destination may be able to spoof trusted servers to steal data or cause a denial of service.\n\n\nThere are at least two distinct weaknesses that can cause the product to communicate with an unintended destination:\n\n\n  - If the product allows an attacker to control which destination is specified, then the attacker can cause it to connect to an untrusted or malicious destination. For example, because UDP is a connectionless protocol, UDP packets can be spoofed by specifying a false source address in the packet; when the server receives the packet and sends a reply, it will specify a destination by using the source of the incoming packet - i.e., the false source. The server can then be tricked into sending traffic to the wrong host, which is effective for hiding the real source of an attack and for conducting a distributed denial of service (DDoS). As another example, server-side request forgery (SSRF) and XML External Entity (XXE) can be used to trick a server into making outgoing requests to hosts that cannot be directly accessed by the attacker due to firewall restrictions.\n\n  - If the product incorrectly specifies the destination, then an attacker who can control this destination might be able to spoof trusted servers. While the most common occurrence is likely due to misconfiguration by an administrator, this can be resultant from other weaknesses. For example, the product might incorrectly parse an e-mail or IP address and send sensitive data to an unintended destination. As another example, an Android application may use a \"sticky broadcast\" to communicate with a receiver for a particular application, but since sticky broadcasts can be processed by *any* receiver, this can allow a malicious application to access restricted data that was only intended for a different application.\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-923\nCanPrecede -> CWE-406\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2013-5211:** composite: NTP feature generates large responses (high amplification factor) with spoofed UDP source addresses.\n- **CVE-1999-0513:** Classic \"Smurf\" attack, using spoofed ICMP packets to broadcast addresses.\n- **CVE-1999-1379:** DNS query with spoofed source address causes more traffic to be returned to spoofed address than was sent by the attacker.\n\n\n\n\n## CWE-117: Improper Output Neutralization for Logs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not neutralize or incorrectly neutralizes output that is written to logs.\n\n### Extended Description\n\n\nThis can allow an attacker to forge log entries or inject malicious content into logs.\n\n\nLog forging vulnerabilities occur when:\n\n\n  1. Data enters an application from an untrusted source.\n\n  1. The data is written to an application or system log file.\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-116\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2006-4624:** Chain: inject fake log entries with fake timestamps using CRLF injection\n\n\n\n\n## CWE-184: Incomplete List of Disallowed Inputs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nDenylist / Deny List: This is used by CWE and CAPEC instead of other commonly-used terms. Its counterpart is allowlist.\nBlocklist / Block List: This is often used by security tools such as firewalls, email or web gateways, proxies, etc.\nBlacklist / Black List: This term is frequently used, but usage has been declining as organizations have started to adopt other terms.\n\n### Relationships\nChildOf -> CWE-693\nChildOf -> CWE-1023\nCanPrecede -> CWE-79\nCanPrecede -> CWE-78\nCanPrecede -> CWE-434\nCanPrecede -> CWE-98\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nMultiple interpretation errors can indirectly introduce inputs that should be disallowed. For example, a list of dangerous shell metacharacters might not include a metacharacter that only has meaning in one particular shell, not all of them; or a check for XSS manipulations might ignore an unusual construct that is supported by one web browser, but not others.\n\n\n\n\n### Observed Examples\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2008-2309:** product uses a denylist to identify potentially dangerous content, allowing attacker to bypass a warning\n- **CVE-2005-2782:** PHP remote file inclusion in web application that filters \"http\" and \"https\" URLs, but not \"ftp\".\n\n\n\n\n## CWE-407: Inefficient Algorithmic Complexity\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nAn algorithm in a product has an inefficient worst-case computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nQuadratic Complexity: Used when the algorithmic complexity is related to the square of the number of inputs (N^2)\n\n### Relationships\nChildOf -> CWE-405\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2021-32617:** C++ library for image metadata has \"quadratic complexity\" issue with unnecessarily repetitive parsing each time an invalid character is encountered\n- **CVE-2020-10735:** Python has \"quadratic complexity\" issue when converting string to int with many digits in unexpected bases\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n\n\n\n\n## CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nCanPrecede -> CWE-117\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1771:** CRLF injection enables spam proxy (add mail headers) using email address or name.\n- **CVE-2002-1783:** CRLF injection in API function arguments modify headers for outgoing requests.\n- **CVE-2004-1513:** Spoofed entries in web server log file via carriage returns\n\n Consider specifically these CWEs: CWE-184 CWE-116 CWE-138 CWE-88 CWE-93 CWE-113 CWE-74 CWE-79",
  "keyphrases": {
    "original_query": "## Vulnerability Description\nClash for Windows v0.19.8 was discovered to allow arbitrary code execution via a crafted payload injected into the Proxies name column.\n\n### Vulnerability Description Key Phrases\n- **impact:** arbitrary code execution\n- **vector:** crafted payload injected into the Proxies name column\n- **product:** Windows\n- **version:** v0.19.8\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.044 |\n| 2 | 78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | sparse | 0.040 |\n| 3 | 116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | sparse | 0.039 |\n| 4 | 94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | sparse | 0.039 |\n| 5 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.038 |\n| 6 | 941 | Incorrectly Specified Destination in a Communication Channel | Base | Allowed | dense | 0.519 |\n| 7 | 117 | Improper Output Neutralization for Logs | Base | Allowed | graph | 0.003 |\n| 8 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | sparse | 0.037 |\n| 9 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 0.037 |\n| 10 | 93 | Improper Neutralization of CRLF Sequences ('CRLF Injection') | Base | Allowed | sparse | 0.036 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n### Extended Description\n\n\nThis weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.\n\n\nThere are at least two subtypes of OS command injection:\n\n\n  - The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.\n\n  - The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.\n\nFrom a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.\n\n### Alternative Terms\nShell injection\nShell metacharacters\nOS Command Injection\n\n### Relationships\nChildOf -> CWE-77\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\nCanAlsoBe -> CWE-88\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** The \"OS command injection\" phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an \"-exec\" switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX \"find\" command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.\n\n**[Research Gap]** More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.\n\n\n\n### Observed Examples\n- **CVE-2020-10987:** OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.\n- **CVE-2020-10221:** Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.\n- **CVE-2020-9054:** Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-116: Improper Encoding or Escaping of Output\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.\n\n### Extended Description\n\n\nImproper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead.\n\n\nMost products follow a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, \"GET /index.html HTTP/1.1\" is a structured message containing a command (\"GET\") with a single argument (\"/index.html\") and metadata about which protocol version is being used (\"HTTP/1.1\").\n\n\nIf an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.\n\n\n### Alternative Terms\nOutput Sanitization\nOutput Validation\nOutput Encoding\n\n### Relationships\nChildOf -> CWE-707\nCanPrecede -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness is primary to all weaknesses related to injection (CWE-74) since the inherent nature of injection involves the violation of structured messages.\n\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\nHowever, input validation is not always sufficient, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise neutralized. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n**[Terminology]** The usage of the \"encoding\" and \"escaping\" terms varies widely. For example, in some programming languages, the terms are used interchangeably, while other languages provide APIs that use both terms for different tasks. This overlapping usage extends to the Web, such as the \"escape\" JavaScript function whose purpose is stated to be encoding. The concepts of encoding and escaping predate the Web by decades. Given such a context, it is difficult for CWE to adopt a consistent vocabulary that will not be misinterpreted by some constituency.\n\n**[Theoretical]** This is a data/directive boundary error in which data boundaries are not sufficiently enforced before it is sent to a different control sphere.\n\n**[Research Gap]** While many published vulnerabilities are related to insufficient output encoding, there is such an emphasis on input validation as a protection mechanism that the underlying causes are rarely described. Within CVE, the focus is primarily on well-understood issues like cross-site scripting and SQL injection. It is likely that this weakness frequently occurs in custom protocols that support multiple encodings, which are not necessarily detectable with automated techniques.\n\n\n\n### Observed Examples\n- **CVE-2021-41232:** Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90)\n- **CVE-2008-4636:** OS command injection in backup software using shell metacharacters in a filename; correct behavior would require that this filename could not be changed.\n- **CVE-2008-0769:** Web application does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.\n\n\n\n\n## CWE-94: Improper Control of Generation of Code ('Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.\n\n### Extended Description\n\n\nWhen a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution.\n\n\nInjection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nChildOf -> CWE-913\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This entry is frequently misused for vulnerabilities with a technical impact of \"code execution,\" which does not by itself indicate a root cause weakness, since dozens of weaknesses can enable code execution.\n**Comments:** This weakness only applies when the product's functionality intentionally constructs all or part of a code segment. It could be that executing code could be the result of other weaknesses that do not involve the construction of code segments.\n**Reasons:**\n- Frequent Misuse\n- Frequent Misinterpretation\n\n\n\n### Observed Examples\n- **CVE-2023-29374:** Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-5565:** Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-941: Incorrectly Specified Destination in a Communication Channel\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product creates a communication channel to initiate an outgoing request to an actor, but it does not correctly specify the intended destination for that actor.\n\n### Extended Description\n\n\nAttackers at the destination may be able to spoof trusted servers to steal data or cause a denial of service.\n\n\nThere are at least two distinct weaknesses that can cause the product to communicate with an unintended destination:\n\n\n  - If the product allows an attacker to control which destination is specified, then the attacker can cause it to connect to an untrusted or malicious destination. For example, because UDP is a connectionless protocol, UDP packets can be spoofed by specifying a false source address in the packet; when the server receives the packet and sends a reply, it will specify a destination by using the source of the incoming packet - i.e., the false source. The server can then be tricked into sending traffic to the wrong host, which is effective for hiding the real source of an attack and for conducting a distributed denial of service (DDoS). As another example, server-side request forgery (SSRF) and XML External Entity (XXE) can be used to trick a server into making outgoing requests to hosts that cannot be directly accessed by the attacker due to firewall restrictions.\n\n  - If the product incorrectly specifies the destination, then an attacker who can control this destination might be able to spoof trusted servers. While the most common occurrence is likely due to misconfiguration by an administrator, this can be resultant from other weaknesses. For example, the product might incorrectly parse an e-mail or IP address and send sensitive data to an unintended destination. As another example, an Android application may use a \"sticky broadcast\" to communicate with a receiver for a particular application, but since sticky broadcasts can be processed by *any* receiver, this can allow a malicious application to access restricted data that was only intended for a different application.\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-923\nCanPrecede -> CWE-406\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2013-5211:** composite: NTP feature generates large responses (high amplification factor) with spoofed UDP source addresses.\n- **CVE-1999-0513:** Classic \"Smurf\" attack, using spoofed ICMP packets to broadcast addresses.\n- **CVE-1999-1379:** DNS query with spoofed source address causes more traffic to be returned to spoofed address than was sent by the attacker.\n\n\n\n\n## CWE-117: Improper Output Neutralization for Logs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not neutralize or incorrectly neutralizes output that is written to logs.\n\n### Extended Description\n\n\nThis can allow an attacker to forge log entries or inject malicious content into logs.\n\n\nLog forging vulnerabilities occur when:\n\n\n  1. Data enters an application from an untrusted source.\n\n  1. The data is written to an application or system log file.\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-116\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2006-4624:** Chain: inject fake log entries with fake timestamps using CRLF injection\n\n\n\n\n## CWE-184: Incomplete List of Disallowed Inputs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nDenylist / Deny List: This is used by CWE and CAPEC instead of other commonly-used terms. Its counterpart is allowlist.\nBlocklist / Block List: This is often used by security tools such as firewalls, email or web gateways, proxies, etc.\nBlacklist / Black List: This term is frequently used, but usage has been declining as organizations have started to adopt other terms.\n\n### Relationships\nChildOf -> CWE-693\nChildOf -> CWE-1023\nCanPrecede -> CWE-79\nCanPrecede -> CWE-78\nCanPrecede -> CWE-434\nCanPrecede -> CWE-98\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nMultiple interpretation errors can indirectly introduce inputs that should be disallowed. For example, a list of dangerous shell metacharacters might not include a metacharacter that only has meaning in one particular shell, not all of them; or a check for XSS manipulations might ignore an unusual construct that is supported by one web browser, but not others.\n\n\n\n\n### Observed Examples\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2008-2309:** product uses a denylist to identify potentially dangerous content, allowing attacker to bypass a warning\n- **CVE-2005-2782:** PHP remote file inclusion in web application that filters \"http\" and \"https\" URLs, but not \"ftp\".\n\n\n\n\n## CWE-407: Inefficient Algorithmic Complexity\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nAn algorithm in a product has an inefficient worst-case computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nQuadratic Complexity: Used when the algorithmic complexity is related to the square of the number of inputs (N^2)\n\n### Relationships\nChildOf -> CWE-405\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2021-32617:** C++ library for image metadata has \"quadratic complexity\" issue with unnecessarily repetitive parsing each time an invalid character is encountered\n- **CVE-2020-10735:** Python has \"quadratic complexity\" issue when converting string to int with many digits in unexpected bases\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n\n\n\n\n## CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nCanPrecede -> CWE-117\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1771:** CRLF injection enables spam proxy (add mail headers) using email address or name.\n- **CVE-2002-1783:** CRLF injection in API function arguments modify headers for outgoing requests.\n- **CVE-2004-1513:** Spoofed entries in web server log file via carriage returns\n\n",
    "enhanced_query": "## Vulnerability Description\nClash for Windows v0.19.8 was discovered to allow arbitrary code execution via a crafted payload injected into the Proxies name column.\n\n### Vulnerability Description Key Phrases\n- **impact:** arbitrary code execution\n- **vector:** crafted payload injected into the Proxies name column\n- **product:** Windows\n- **version:** v0.19.8\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.044 |\n| 2 | 78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | sparse | 0.040 |\n| 3 | 116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | sparse | 0.039 |\n| 4 | 94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | sparse | 0.039 |\n| 5 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.038 |\n| 6 | 941 | Incorrectly Specified Destination in a Communication Channel | Base | Allowed | dense | 0.519 |\n| 7 | 117 | Improper Output Neutralization for Logs | Base | Allowed | graph | 0.003 |\n| 8 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | sparse | 0.037 |\n| 9 | 407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | sparse | 0.037 |\n| 10 | 93 | Improper Neutralization of CRLF Sequences ('CRLF Injection') | Base | Allowed | sparse | 0.036 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n### Extended Description\n\n\nThis weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.\n\n\nThere are at least two subtypes of OS command injection:\n\n\n  - The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.\n\n  - The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.\n\nFrom a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.\n\n### Alternative Terms\nShell injection\nShell metacharacters\nOS Command Injection\n\n### Relationships\nChildOf -> CWE-77\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\nCanAlsoBe -> CWE-88\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** The \"OS command injection\" phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an \"-exec\" switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX \"find\" command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.\n\n**[Research Gap]** More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.\n\n\n\n### Observed Examples\n- **CVE-2020-10987:** OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.\n- **CVE-2020-10221:** Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.\n- **CVE-2020-9054:** Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-116: Improper Encoding or Escaping of Output\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.\n\n### Extended Description\n\n\nImproper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead.\n\n\nMost products follow a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, \"GET /index.html HTTP/1.1\" is a structured message containing a command (\"GET\") with a single argument (\"/index.html\") and metadata about which protocol version is being used (\"HTTP/1.1\").\n\n\nIf an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.\n\n\n### Alternative Terms\nOutput Sanitization\nOutput Validation\nOutput Encoding\n\n### Relationships\nChildOf -> CWE-707\nCanPrecede -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness is primary to all weaknesses related to injection (CWE-74) since the inherent nature of injection involves the violation of structured messages.\n\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\nHowever, input validation is not always sufficient, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise neutralized. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n**[Terminology]** The usage of the \"encoding\" and \"escaping\" terms varies widely. For example, in some programming languages, the terms are used interchangeably, while other languages provide APIs that use both terms for different tasks. This overlapping usage extends to the Web, such as the \"escape\" JavaScript function whose purpose is stated to be encoding. The concepts of encoding and escaping predate the Web by decades. Given such a context, it is difficult for CWE to adopt a consistent vocabulary that will not be misinterpreted by some constituency.\n\n**[Theoretical]** This is a data/directive boundary error in which data boundaries are not sufficiently enforced before it is sent to a different control sphere.\n\n**[Research Gap]** While many published vulnerabilities are related to insufficient output encoding, there is such an emphasis on input validation as a protection mechanism that the underlying causes are rarely described. Within CVE, the focus is primarily on well-understood issues like cross-site scripting and SQL injection. It is likely that this weakness frequently occurs in custom protocols that support multiple encodings, which are not necessarily detectable with automated techniques.\n\n\n\n### Observed Examples\n- **CVE-2021-41232:** Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90)\n- **CVE-2008-4636:** OS command injection in backup software using shell metacharacters in a filename; correct behavior would require that this filename could not be changed.\n- **CVE-2008-0769:** Web application does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.\n\n\n\n\n## CWE-94: Improper Control of Generation of Code ('Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.\n\n### Extended Description\n\n\nWhen a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution.\n\n\nInjection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nChildOf -> CWE-913\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This entry is frequently misused for vulnerabilities with a technical impact of \"code execution,\" which does not by itself indicate a root cause weakness, since dozens of weaknesses can enable code execution.\n**Comments:** This weakness only applies when the product's functionality intentionally constructs all or part of a code segment. It could be that executing code could be the result of other weaknesses that do not involve the construction of code segments.\n**Reasons:**\n- Frequent Misuse\n- Frequent Misinterpretation\n\n\n\n### Observed Examples\n- **CVE-2023-29374:** Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-5565:** Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-941: Incorrectly Specified Destination in a Communication Channel\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product creates a communication channel to initiate an outgoing request to an actor, but it does not correctly specify the intended destination for that actor.\n\n### Extended Description\n\n\nAttackers at the destination may be able to spoof trusted servers to steal data or cause a denial of service.\n\n\nThere are at least two distinct weaknesses that can cause the product to communicate with an unintended destination:\n\n\n  - If the product allows an attacker to control which destination is specified, then the attacker can cause it to connect to an untrusted or malicious destination. For example, because UDP is a connectionless protocol, UDP packets can be spoofed by specifying a false source address in the packet; when the server receives the packet and sends a reply, it will specify a destination by using the source of the incoming packet - i.e., the false source. The server can then be tricked into sending traffic to the wrong host, which is effective for hiding the real source of an attack and for conducting a distributed denial of service (DDoS). As another example, server-side request forgery (SSRF) and XML External Entity (XXE) can be used to trick a server into making outgoing requests to hosts that cannot be directly accessed by the attacker due to firewall restrictions.\n\n  - If the product incorrectly specifies the destination, then an attacker who can control this destination might be able to spoof trusted servers. While the most common occurrence is likely due to misconfiguration by an administrator, this can be resultant from other weaknesses. For example, the product might incorrectly parse an e-mail or IP address and send sensitive data to an unintended destination. As another example, an Android application may use a \"sticky broadcast\" to communicate with a receiver for a particular application, but since sticky broadcasts can be processed by *any* receiver, this can allow a malicious application to access restricted data that was only intended for a different application.\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-923\nCanPrecede -> CWE-406\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2013-5211:** composite: NTP feature generates large responses (high amplification factor) with spoofed UDP source addresses.\n- **CVE-1999-0513:** Classic \"Smurf\" attack, using spoofed ICMP packets to broadcast addresses.\n- **CVE-1999-1379:** DNS query with spoofed source address causes more traffic to be returned to spoofed address than was sent by the attacker.\n\n\n\n\n## CWE-117: Improper Output Neutralization for Logs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not neutralize or incorrectly neutralizes output that is written to logs.\n\n### Extended Description\n\n\nThis can allow an attacker to forge log entries or inject malicious content into logs.\n\n\nLog forging vulnerabilities occur when:\n\n\n  1. Data enters an application from an untrusted source.\n\n  1. The data is written to an application or system log file.\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-116\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2006-4624:** Chain: inject fake log entries with fake timestamps using CRLF injection\n\n\n\n\n## CWE-184: Incomplete List of Disallowed Inputs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nDenylist / Deny List: This is used by CWE and CAPEC instead of other commonly-used terms. Its counterpart is allowlist.\nBlocklist / Block List: This is often used by security tools such as firewalls, email or web gateways, proxies, etc.\nBlacklist / Black List: This term is frequently used, but usage has been declining as organizations have started to adopt other terms.\n\n### Relationships\nChildOf -> CWE-693\nChildOf -> CWE-1023\nCanPrecede -> CWE-79\nCanPrecede -> CWE-78\nCanPrecede -> CWE-434\nCanPrecede -> CWE-98\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nMultiple interpretation errors can indirectly introduce inputs that should be disallowed. For example, a list of dangerous shell metacharacters might not include a metacharacter that only has meaning in one particular shell, not all of them; or a check for XSS manipulations might ignore an unusual construct that is supported by one web browser, but not others.\n\n\n\n\n### Observed Examples\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2008-2309:** product uses a denylist to identify potentially dangerous content, allowing attacker to bypass a warning\n- **CVE-2005-2782:** PHP remote file inclusion in web application that filters \"http\" and \"https\" URLs, but not \"ftp\".\n\n\n\n\n## CWE-407: Inefficient Algorithmic Complexity\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nAn algorithm in a product has an inefficient worst-case computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nQuadratic Complexity: Used when the algorithmic complexity is related to the square of the number of inputs (N^2)\n\n### Relationships\nChildOf -> CWE-405\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2021-32617:** C++ library for image metadata has \"quadratic complexity\" issue with unnecessarily repetitive parsing each time an invalid character is encountered\n- **CVE-2020-10735:** Python has \"quadratic complexity\" issue when converting string to int with many digits in unexpected bases\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n\n\n\n\n## CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nCanPrecede -> CWE-117\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1771:** CRLF injection enables spam proxy (add mail headers) using email address or name.\n- **CVE-2002-1783:** CRLF injection in API function arguments modify headers for outgoing requests.\n- **CVE-2004-1513:** Spoofed entries in web server log file via carriage returns\n\n Consider specifically these CWEs: CWE-184 CWE-116 CWE-138 CWE-88 CWE-93 CWE-113 CWE-74 CWE-79",
    "cwe_mentions": [
      "CWE-184",
      "CWE-116",
      "CWE-138",
      "CWE-88",
      "CWE-93",
      "CWE-113",
      "CWE-74",
      "CWE-79"
    ],
    "search_time": 3.83113694190979
  },
  "timestamp": "2025-03-30 20:55:11",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "79",
      "name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "78",
      "name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "494",
      "name": "Download of Code Without Integrity Check",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "434",
      "name": "Unrestricted Upload of File with Dangerous Type",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "94",
      "name": "Improper Control of Generation of Code ('Code Injection')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "117",
      "name": "Improper Output Neutralization for Logs",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "941",
      "name": "Incorrectly Specified Destination in a Communication Channel",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "98",
      "name": "Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')",
      "type": "variant",
      "score": 3.888,
      "relationship_count": 0
    },
    {
      "cwe_id": "88",
      "name": "Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    }
  ]
}