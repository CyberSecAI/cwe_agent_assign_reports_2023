{
  "retriever": "graph",
  "query": "## Vulnerability Description\nA stored **cross-site scripting** vulnerability exists in the WebUserActions.aspx functionality of Lansweeper lansweeper 9.1.20.2. A specially-crafted HTTP request can lead to arbitrary Javascript code injection. An attacker can send an HTTP request to trigger this vulnerability.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input sanitization**\n- **weakness:** **cross-site scripting**\n- **impact:** arbitrary Javascript code injection\n- **vector:** specially-crafted HTTP request\n- **attacker:** attacker\n- **product:** Lansweeper\n- **version:** 9.1.20.2\n- **component:** WebUserActions.aspx functionality\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's a breakdown of the vulnerability:\n\n**CVE ID:** CVE-2022-21145\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from insufficient sanitization of user-controlled input in the `WebUserActions.aspx` page, specifically when updating the `loginmessage` and `loginfootertext` fields of the `TsysCustomLayout` table. The application attempts to sanitize the input using `HtmlSanitizer.SanitizeHtml` but this can be bypassed by manipulating the `name` parameter of the HTTP request.\n\n**Weaknesses/Vulnerabilities Present:**\n- **Stored Cross-Site Scripting (XSS):** The primary vulnerability is a stored XSS flaw. Malicious JavaScript code can be injected and stored in the database, which is then executed when a user visits the login page.\n- **Insufficient Input Sanitization:** The application does not properly sanitize the input provided through the `name` and `value` parameters allowing an attacker to bypass the sanitization attempt in `line 240` of the code.\n- **Lack of Proper Input Validation:** The vulnerability highlights the absence of adequate input validation when parameters `name` and `value` are processed.\n\n**Impact of Exploitation:**\n- **Arbitrary JavaScript Code Injection:** An attacker can inject and execute arbitrary JavaScript code within the context of the Lansweeper login page.\n- **Account Compromise:** By executing malicious JavaScript, an attacker could potentially steal user credentials, session cookies, or perform other malicious actions on behalf of legitimate users.\n- **Phishing/Malware Distribution:**  The injected script could be used to redirect users to phishing pages or serve malware.\n- **Defacement:** The injected code could alter the visual appearance of the login page.\n\n**Attack Vectors:**\n- **HTTP Request Manipulation:** The vulnerability is triggered by sending a specially crafted HTTP POST request to the `/configuration/WebUsers/WebUserActions.aspx?action=loginlayout` endpoint.\n- **Parameter Manipulation:** Attackers can manipulate the `name` and `value` parameters in the HTTP request to bypass the sanitization attempt.\n\n**Required Attacker Capabilities/Position:**\n- **Authentication:** The attacker must be an authenticated Lansweeper user with permissions to change `loginlayout` fields (Configuration -> Website Settings).\n- **Network Access:** The attacker needs to be able to send HTTP requests to the Lansweeper server.\n\n**Technical Details:**\n- The vulnerable code is located in the `\\LS\\CF\\WebUserActions.cs` file.\n- The sanitization logic is in `line 240` of the code, specifically the `text5 == \"loginmessage\" || text5 == \"loginfootertext\"` check.\n- The vulnerability can be bypassed by manipulating the `name` parameter to be \"Loginmessage\" or \" loginmessage\" allowing the attacker to insert unsanitized data to the database through the value parameter.\n- The injected code is executed each time a user visits the Lansweeper login page.\n\nThis information is more detailed than the official CVE description which is a placeholder.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 80 | Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) | Variant | Allowed | sparse | 0.441 |\n| 2 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.324 |\n| 3 | 89 | Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') | Base | Allowed | sparse | 0.304 |\n| 4 | 138 | Improper Neutralization of Special Elements | Class | Discouraged | sparse | 0.302 |\n| 5 | 352 | Cross-Site Request Forgery (CSRF) | Compound | Allowed | sparse | 0.283 |\n| 6 | 644 | Improper Neutralization of HTTP Headers for Scripting Syntax | Variant | Allowed | dense | 0.566 |\n| 7 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | graph | 0.002 |\n| 8 | 1287 | Improper Validation of Specified Type of Input | Base | Allowed | sparse | 0.275 |\n| 9 | 134 | Use of Externally-Controlled Format String | Base | Allowed | sparse | 0.269 |\n| 10 | 918 | Server-Side Request Forgery (SSRF) | Base | Allowed | sparse | 0.267 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as \"<\", \">\", and \"&\" that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.\n\n### Extended Description\nThis may allow such characters to be treated as control characters, which are executed client-side in the context of the user's session. Although this can be classified as an injection problem, the more pertinent issue is the improper conversion of such special characters to respective context-appropriate entities before displaying them to the user.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-79\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-0938:** XSS in parameter in a link.\n- **CVE-2002-1495:** XSS in web-based email product via attachment filenames.\n- **CVE-2003-1136:** HTML injection in posted message.\n\n\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component. Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nSQL injection: a common attack-oriented phrase\nSQLi: a common abbreviation for \"SQL injection\"\n\n### Relationships\nChildOf -> CWE-943\nChildOf -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** SQL injection can be resultant from special character mismanagement, MAID, or denylist/allowlist problems. It can be primary to authentication errors.\n\n\n\n### Observed Examples\n- **CVE-2023-32530:** SQL injection in security product dashboard using crafted certificate fields\n- **CVE-2021-42258:** SQL injection in time and billing software, as exploited in the wild per CISA KEV.\n- **CVE-2021-27101:** SQL injection in file-transfer system via a crafted Host header, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-138: Improper Neutralization of Special Elements\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.\n\n### Extended Description\nMost languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If product does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (\"less than\") as meaning \"read input from a file\".\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness can be related to interpretation conflicts or interaction errors in intermediaries (such as proxies or application firewalls) when the intermediary's model of an endpoint does not account for protocol-specific special elements.\n\n**[Relationship]** See this entry's children for different types of special elements that have been observed at one point or another. However, it can be difficult to find suitable CVE examples. In an attempt to be complete, CWE includes some types that do not have any associated observed example.\n\n**[Research Gap]** This weakness is probably under-studied for proprietary or custom formats. It is likely that these issues are fairly common in applications that use their own custom format for configuration files, logs, meta-data, messaging, etc. They would only be found by accident or with a focused effort based on an understanding of the format.\n\n\n\n### Observed Examples\n- **CVE-2001-0677:** Read arbitrary files from mail client by providing a special MIME header that is internally used to store pathnames for attachments.\n- **CVE-2000-0703:** Setuid program does not cleanse special escape sequence before sending data to a mail program, causing the mail program to process those sequences.\n- **CVE-2003-0020:** Multi-channel issue. Terminal escape sequences not filtered from log files.\n\n\n\n\n## CWE-352: Cross-Site Request Forgery (CSRF)\n**Abstraction:** Compound\n**Status:** Stable\n\n### Description\nThe web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.\n\n### Extended Description\nWhen a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.\n\n### Alternative Terms\nSession Riding\nCross Site Reference Forgery\nXSRF\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\nRequires -> CWE-346\nRequires -> CWE-441\nRequires -> CWE-642\nRequires -> CWE-613\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This is a well-known Composite of multiple weaknesses that must all occur simultaneously, although it is attack-oriented in nature.\n**Comments:** While attack-oriented composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine if other weaknesses allow CSRF attacks to occur, and map to those weaknesses. For example, predictable CSRF tokens might allow bypass of CSRF protection mechanisms; if this occurs, they might be better characterized as randomness/predictability weaknesses.\n**Reasons:**\n- Other\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Theoretical]** \n\nThe CSRF topology is multi-channel:\n\n\n  - Attacker (as outsider) to intermediary (as user). The interaction point is either an external or internal channel.\n\n  - Intermediary (as user) to server (as victim). The activation point is an internal channel.\n\n\n\n\n\n### Observed Examples\n- **CVE-2004-1703:** Add user accounts via a URL in an img tag\n- **CVE-2004-1995:** Add user accounts via a URL in an img tag\n- **CVE-2004-1967:** Arbitrary code execution by specifying the code in a crafted img tag or URL\n\n\n\n\n## CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product does not neutralize or incorrectly neutralizes web scripting syntax in HTTP headers that can be used by web browser components that can process raw headers, such as Flash.\n\n### Extended Description\n\n\nAn attacker may be able to conduct cross-site scripting and other attacks against users who have these components enabled.\n\n\nIf a product does not neutralize user controlled data being placed in the header of an HTTP response coming from the server, the header may contain a script that will get executed in the client's browser context, potentially resulting in a cross site scripting vulnerability or possibly an HTTP response splitting attack. It is important to carefully control data that is being placed both in HTTP response header and in the HTTP response body to ensure that no scripting syntax is present, taking various encodings into account.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-116\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2006-3918:** Web server does not remove the Expect header from an HTTP request when it is reflected back in an error message, allowing a Flash SWF file to perform XSS attacks.\n\n\n\n\n## CWE-184: Incomplete List of Disallowed Inputs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nDenylist / Deny List: This is used by CWE and CAPEC instead of other commonly-used terms. Its counterpart is allowlist.\nBlocklist / Block List: This is often used by security tools such as firewalls, email or web gateways, proxies, etc.\nBlacklist / Black List: This term is frequently used, but usage has been declining as organizations have started to adopt other terms.\n\n### Relationships\nChildOf -> CWE-693\nChildOf -> CWE-1023\nCanPrecede -> CWE-79\nCanPrecede -> CWE-78\nCanPrecede -> CWE-434\nCanPrecede -> CWE-98\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nMultiple interpretation errors can indirectly introduce inputs that should be disallowed. For example, a list of dangerous shell metacharacters might not include a metacharacter that only has meaning in one particular shell, not all of them; or a check for XSS manipulations might ignore an unusual construct that is supported by one web browser, but not others.\n\n\n\n\n### Observed Examples\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2008-2309:** product uses a denylist to identify potentially dangerous content, allowing attacker to bypass a warning\n- **CVE-2005-2782:** PHP remote file inclusion in web application that filters \"http\" and \"https\" URLs, but not \"ftp\".\n\n\n\n\n## CWE-1287: Improper Validation of Specified Type of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.\n\n### Extended Description\n\n\nWhen input does not comply with the expected type, attackers could trigger unexpected errors, cause incorrect actions to take place, or exploit latent vulnerabilities that would not be possible if the input conformed with the expected type.\n\n\nThis weakness can appear in type-unsafe programming languages, or in programming languages that support casting or conversion of an input to another type.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nPeerOf -> CWE-843\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2008-2223:** SQL injection through an ID that was supposed to be numeric.\n\n\n\n\n## CWE-134: Use of Externally-Controlled Format String\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source.\n\n### Extended Description\n\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-668\nChildOf -> CWE-668\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any programming language that support format strings.\n\n\n**[Other]** \n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n\n\n**[Research Gap]** Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.\n\n\n\n### Observed Examples\n- **CVE-2002-1825:** format string in Perl program\n- **CVE-2001-0717:** format string in bad call to syslog function\n- **CVE-2002-0573:** format string in bad call to syslog function\n\n\n\n\n## CWE-918: Server-Side Request Forgery (SSRF)\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nXSPA: Cross Site Port Attack\nSSRF: Server-Side Request Forgery\n\n### Relationships\nChildOf -> CWE-441\nChildOf -> CWE-610\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2023-32786:** Chain: LLM integration framework has prompt injection (CWE-1427) that allows an attacker to force the service to retrieve data from an arbitrary URL, essentially providing SSRF (CWE-918) and potentially injecting content into downstream tasks.\n- **CVE-2021-26855:** Server Side Request Forgery (SSRF) in mail server, as exploited in the wild per CISA KEV.\n- **CVE-2021-21973:** Server Side Request Forgery in cloud platform, as exploited in the wild per CISA KEV.\n\n Consider specifically these CWEs: CWE-80 CWE-918 CWE-184 CWE-116 CWE-138 CWE-113 CWE-74 CWE-79",
  "keyphrases": {
    "original_query": "## Vulnerability Description\nA stored **cross-site scripting** vulnerability exists in the WebUserActions.aspx functionality of Lansweeper lansweeper 9.1.20.2. A specially-crafted HTTP request can lead to arbitrary Javascript code injection. An attacker can send an HTTP request to trigger this vulnerability.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input sanitization**\n- **weakness:** **cross-site scripting**\n- **impact:** arbitrary Javascript code injection\n- **vector:** specially-crafted HTTP request\n- **attacker:** attacker\n- **product:** Lansweeper\n- **version:** 9.1.20.2\n- **component:** WebUserActions.aspx functionality\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's a breakdown of the vulnerability:\n\n**CVE ID:** CVE-2022-21145\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from insufficient sanitization of user-controlled input in the `WebUserActions.aspx` page, specifically when updating the `loginmessage` and `loginfootertext` fields of the `TsysCustomLayout` table. The application attempts to sanitize the input using `HtmlSanitizer.SanitizeHtml` but this can be bypassed by manipulating the `name` parameter of the HTTP request.\n\n**Weaknesses/Vulnerabilities Present:**\n- **Stored Cross-Site Scripting (XSS):** The primary vulnerability is a stored XSS flaw. Malicious JavaScript code can be injected and stored in the database, which is then executed when a user visits the login page.\n- **Insufficient Input Sanitization:** The application does not properly sanitize the input provided through the `name` and `value` parameters allowing an attacker to bypass the sanitization attempt in `line 240` of the code.\n- **Lack of Proper Input Validation:** The vulnerability highlights the absence of adequate input validation when parameters `name` and `value` are processed.\n\n**Impact of Exploitation:**\n- **Arbitrary JavaScript Code Injection:** An attacker can inject and execute arbitrary JavaScript code within the context of the Lansweeper login page.\n- **Account Compromise:** By executing malicious JavaScript, an attacker could potentially steal user credentials, session cookies, or perform other malicious actions on behalf of legitimate users.\n- **Phishing/Malware Distribution:**  The injected script could be used to redirect users to phishing pages or serve malware.\n- **Defacement:** The injected code could alter the visual appearance of the login page.\n\n**Attack Vectors:**\n- **HTTP Request Manipulation:** The vulnerability is triggered by sending a specially crafted HTTP POST request to the `/configuration/WebUsers/WebUserActions.aspx?action=loginlayout` endpoint.\n- **Parameter Manipulation:** Attackers can manipulate the `name` and `value` parameters in the HTTP request to bypass the sanitization attempt.\n\n**Required Attacker Capabilities/Position:**\n- **Authentication:** The attacker must be an authenticated Lansweeper user with permissions to change `loginlayout` fields (Configuration -> Website Settings).\n- **Network Access:** The attacker needs to be able to send HTTP requests to the Lansweeper server.\n\n**Technical Details:**\n- The vulnerable code is located in the `\\LS\\CF\\WebUserActions.cs` file.\n- The sanitization logic is in `line 240` of the code, specifically the `text5 == \"loginmessage\" || text5 == \"loginfootertext\"` check.\n- The vulnerability can be bypassed by manipulating the `name` parameter to be \"Loginmessage\" or \" loginmessage\" allowing the attacker to insert unsanitized data to the database through the value parameter.\n- The injected code is executed each time a user visits the Lansweeper login page.\n\nThis information is more detailed than the official CVE description which is a placeholder.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 80 | Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) | Variant | Allowed | sparse | 0.441 |\n| 2 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.324 |\n| 3 | 89 | Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') | Base | Allowed | sparse | 0.304 |\n| 4 | 138 | Improper Neutralization of Special Elements | Class | Discouraged | sparse | 0.302 |\n| 5 | 352 | Cross-Site Request Forgery (CSRF) | Compound | Allowed | sparse | 0.283 |\n| 6 | 644 | Improper Neutralization of HTTP Headers for Scripting Syntax | Variant | Allowed | dense | 0.566 |\n| 7 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | graph | 0.002 |\n| 8 | 1287 | Improper Validation of Specified Type of Input | Base | Allowed | sparse | 0.275 |\n| 9 | 134 | Use of Externally-Controlled Format String | Base | Allowed | sparse | 0.269 |\n| 10 | 918 | Server-Side Request Forgery (SSRF) | Base | Allowed | sparse | 0.267 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as \"<\", \">\", and \"&\" that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.\n\n### Extended Description\nThis may allow such characters to be treated as control characters, which are executed client-side in the context of the user's session. Although this can be classified as an injection problem, the more pertinent issue is the improper conversion of such special characters to respective context-appropriate entities before displaying them to the user.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-79\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-0938:** XSS in parameter in a link.\n- **CVE-2002-1495:** XSS in web-based email product via attachment filenames.\n- **CVE-2003-1136:** HTML injection in posted message.\n\n\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component. Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nSQL injection: a common attack-oriented phrase\nSQLi: a common abbreviation for \"SQL injection\"\n\n### Relationships\nChildOf -> CWE-943\nChildOf -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** SQL injection can be resultant from special character mismanagement, MAID, or denylist/allowlist problems. It can be primary to authentication errors.\n\n\n\n### Observed Examples\n- **CVE-2023-32530:** SQL injection in security product dashboard using crafted certificate fields\n- **CVE-2021-42258:** SQL injection in time and billing software, as exploited in the wild per CISA KEV.\n- **CVE-2021-27101:** SQL injection in file-transfer system via a crafted Host header, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-138: Improper Neutralization of Special Elements\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.\n\n### Extended Description\nMost languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If product does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (\"less than\") as meaning \"read input from a file\".\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness can be related to interpretation conflicts or interaction errors in intermediaries (such as proxies or application firewalls) when the intermediary's model of an endpoint does not account for protocol-specific special elements.\n\n**[Relationship]** See this entry's children for different types of special elements that have been observed at one point or another. However, it can be difficult to find suitable CVE examples. In an attempt to be complete, CWE includes some types that do not have any associated observed example.\n\n**[Research Gap]** This weakness is probably under-studied for proprietary or custom formats. It is likely that these issues are fairly common in applications that use their own custom format for configuration files, logs, meta-data, messaging, etc. They would only be found by accident or with a focused effort based on an understanding of the format.\n\n\n\n### Observed Examples\n- **CVE-2001-0677:** Read arbitrary files from mail client by providing a special MIME header that is internally used to store pathnames for attachments.\n- **CVE-2000-0703:** Setuid program does not cleanse special escape sequence before sending data to a mail program, causing the mail program to process those sequences.\n- **CVE-2003-0020:** Multi-channel issue. Terminal escape sequences not filtered from log files.\n\n\n\n\n## CWE-352: Cross-Site Request Forgery (CSRF)\n**Abstraction:** Compound\n**Status:** Stable\n\n### Description\nThe web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.\n\n### Extended Description\nWhen a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.\n\n### Alternative Terms\nSession Riding\nCross Site Reference Forgery\nXSRF\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\nRequires -> CWE-346\nRequires -> CWE-441\nRequires -> CWE-642\nRequires -> CWE-613\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This is a well-known Composite of multiple weaknesses that must all occur simultaneously, although it is attack-oriented in nature.\n**Comments:** While attack-oriented composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine if other weaknesses allow CSRF attacks to occur, and map to those weaknesses. For example, predictable CSRF tokens might allow bypass of CSRF protection mechanisms; if this occurs, they might be better characterized as randomness/predictability weaknesses.\n**Reasons:**\n- Other\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Theoretical]** \n\nThe CSRF topology is multi-channel:\n\n\n  - Attacker (as outsider) to intermediary (as user). The interaction point is either an external or internal channel.\n\n  - Intermediary (as user) to server (as victim). The activation point is an internal channel.\n\n\n\n\n\n### Observed Examples\n- **CVE-2004-1703:** Add user accounts via a URL in an img tag\n- **CVE-2004-1995:** Add user accounts via a URL in an img tag\n- **CVE-2004-1967:** Arbitrary code execution by specifying the code in a crafted img tag or URL\n\n\n\n\n## CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product does not neutralize or incorrectly neutralizes web scripting syntax in HTTP headers that can be used by web browser components that can process raw headers, such as Flash.\n\n### Extended Description\n\n\nAn attacker may be able to conduct cross-site scripting and other attacks against users who have these components enabled.\n\n\nIf a product does not neutralize user controlled data being placed in the header of an HTTP response coming from the server, the header may contain a script that will get executed in the client's browser context, potentially resulting in a cross site scripting vulnerability or possibly an HTTP response splitting attack. It is important to carefully control data that is being placed both in HTTP response header and in the HTTP response body to ensure that no scripting syntax is present, taking various encodings into account.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-116\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2006-3918:** Web server does not remove the Expect header from an HTTP request when it is reflected back in an error message, allowing a Flash SWF file to perform XSS attacks.\n\n\n\n\n## CWE-184: Incomplete List of Disallowed Inputs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nDenylist / Deny List: This is used by CWE and CAPEC instead of other commonly-used terms. Its counterpart is allowlist.\nBlocklist / Block List: This is often used by security tools such as firewalls, email or web gateways, proxies, etc.\nBlacklist / Black List: This term is frequently used, but usage has been declining as organizations have started to adopt other terms.\n\n### Relationships\nChildOf -> CWE-693\nChildOf -> CWE-1023\nCanPrecede -> CWE-79\nCanPrecede -> CWE-78\nCanPrecede -> CWE-434\nCanPrecede -> CWE-98\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nMultiple interpretation errors can indirectly introduce inputs that should be disallowed. For example, a list of dangerous shell metacharacters might not include a metacharacter that only has meaning in one particular shell, not all of them; or a check for XSS manipulations might ignore an unusual construct that is supported by one web browser, but not others.\n\n\n\n\n### Observed Examples\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2008-2309:** product uses a denylist to identify potentially dangerous content, allowing attacker to bypass a warning\n- **CVE-2005-2782:** PHP remote file inclusion in web application that filters \"http\" and \"https\" URLs, but not \"ftp\".\n\n\n\n\n## CWE-1287: Improper Validation of Specified Type of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.\n\n### Extended Description\n\n\nWhen input does not comply with the expected type, attackers could trigger unexpected errors, cause incorrect actions to take place, or exploit latent vulnerabilities that would not be possible if the input conformed with the expected type.\n\n\nThis weakness can appear in type-unsafe programming languages, or in programming languages that support casting or conversion of an input to another type.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nPeerOf -> CWE-843\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2008-2223:** SQL injection through an ID that was supposed to be numeric.\n\n\n\n\n## CWE-134: Use of Externally-Controlled Format String\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source.\n\n### Extended Description\n\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-668\nChildOf -> CWE-668\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any programming language that support format strings.\n\n\n**[Other]** \n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n\n\n**[Research Gap]** Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.\n\n\n\n### Observed Examples\n- **CVE-2002-1825:** format string in Perl program\n- **CVE-2001-0717:** format string in bad call to syslog function\n- **CVE-2002-0573:** format string in bad call to syslog function\n\n\n\n\n## CWE-918: Server-Side Request Forgery (SSRF)\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nXSPA: Cross Site Port Attack\nSSRF: Server-Side Request Forgery\n\n### Relationships\nChildOf -> CWE-441\nChildOf -> CWE-610\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2023-32786:** Chain: LLM integration framework has prompt injection (CWE-1427) that allows an attacker to force the service to retrieve data from an arbitrary URL, essentially providing SSRF (CWE-918) and potentially injecting content into downstream tasks.\n- **CVE-2021-26855:** Server Side Request Forgery (SSRF) in mail server, as exploited in the wild per CISA KEV.\n- **CVE-2021-21973:** Server Side Request Forgery in cloud platform, as exploited in the wild per CISA KEV.\n\n",
    "enhanced_query": "## Vulnerability Description\nA stored **cross-site scripting** vulnerability exists in the WebUserActions.aspx functionality of Lansweeper lansweeper 9.1.20.2. A specially-crafted HTTP request can lead to arbitrary Javascript code injection. An attacker can send an HTTP request to trigger this vulnerability.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input sanitization**\n- **weakness:** **cross-site scripting**\n- **impact:** arbitrary Javascript code injection\n- **vector:** specially-crafted HTTP request\n- **attacker:** attacker\n- **product:** Lansweeper\n- **version:** 9.1.20.2\n- **component:** WebUserActions.aspx functionality\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's a breakdown of the vulnerability:\n\n**CVE ID:** CVE-2022-21145\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from insufficient sanitization of user-controlled input in the `WebUserActions.aspx` page, specifically when updating the `loginmessage` and `loginfootertext` fields of the `TsysCustomLayout` table. The application attempts to sanitize the input using `HtmlSanitizer.SanitizeHtml` but this can be bypassed by manipulating the `name` parameter of the HTTP request.\n\n**Weaknesses/Vulnerabilities Present:**\n- **Stored Cross-Site Scripting (XSS):** The primary vulnerability is a stored XSS flaw. Malicious JavaScript code can be injected and stored in the database, which is then executed when a user visits the login page.\n- **Insufficient Input Sanitization:** The application does not properly sanitize the input provided through the `name` and `value` parameters allowing an attacker to bypass the sanitization attempt in `line 240` of the code.\n- **Lack of Proper Input Validation:** The vulnerability highlights the absence of adequate input validation when parameters `name` and `value` are processed.\n\n**Impact of Exploitation:**\n- **Arbitrary JavaScript Code Injection:** An attacker can inject and execute arbitrary JavaScript code within the context of the Lansweeper login page.\n- **Account Compromise:** By executing malicious JavaScript, an attacker could potentially steal user credentials, session cookies, or perform other malicious actions on behalf of legitimate users.\n- **Phishing/Malware Distribution:**  The injected script could be used to redirect users to phishing pages or serve malware.\n- **Defacement:** The injected code could alter the visual appearance of the login page.\n\n**Attack Vectors:**\n- **HTTP Request Manipulation:** The vulnerability is triggered by sending a specially crafted HTTP POST request to the `/configuration/WebUsers/WebUserActions.aspx?action=loginlayout` endpoint.\n- **Parameter Manipulation:** Attackers can manipulate the `name` and `value` parameters in the HTTP request to bypass the sanitization attempt.\n\n**Required Attacker Capabilities/Position:**\n- **Authentication:** The attacker must be an authenticated Lansweeper user with permissions to change `loginlayout` fields (Configuration -> Website Settings).\n- **Network Access:** The attacker needs to be able to send HTTP requests to the Lansweeper server.\n\n**Technical Details:**\n- The vulnerable code is located in the `\\LS\\CF\\WebUserActions.cs` file.\n- The sanitization logic is in `line 240` of the code, specifically the `text5 == \"loginmessage\" || text5 == \"loginfootertext\"` check.\n- The vulnerability can be bypassed by manipulating the `name` parameter to be \"Loginmessage\" or \" loginmessage\" allowing the attacker to insert unsanitized data to the database through the value parameter.\n- The injected code is executed each time a user visits the Lansweeper login page.\n\nThis information is more detailed than the official CVE description which is a placeholder.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 80 | Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) | Variant | Allowed | sparse | 0.441 |\n| 2 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.324 |\n| 3 | 89 | Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') | Base | Allowed | sparse | 0.304 |\n| 4 | 138 | Improper Neutralization of Special Elements | Class | Discouraged | sparse | 0.302 |\n| 5 | 352 | Cross-Site Request Forgery (CSRF) | Compound | Allowed | sparse | 0.283 |\n| 6 | 644 | Improper Neutralization of HTTP Headers for Scripting Syntax | Variant | Allowed | dense | 0.566 |\n| 7 | 184 | Incomplete List of Disallowed Inputs | Base | Allowed | graph | 0.002 |\n| 8 | 1287 | Improper Validation of Specified Type of Input | Base | Allowed | sparse | 0.275 |\n| 9 | 134 | Use of Externally-Controlled Format String | Base | Allowed | sparse | 0.269 |\n| 10 | 918 | Server-Side Request Forgery (SSRF) | Base | Allowed | sparse | 0.267 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as \"<\", \">\", and \"&\" that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.\n\n### Extended Description\nThis may allow such characters to be treated as control characters, which are executed client-side in the context of the user's session. Although this can be classified as an injection problem, the more pertinent issue is the improper conversion of such special characters to respective context-appropriate entities before displaying them to the user.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-79\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-0938:** XSS in parameter in a link.\n- **CVE-2002-1495:** XSS in web-based email product via attachment filenames.\n- **CVE-2003-1136:** HTML injection in posted message.\n\n\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component. Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nSQL injection: a common attack-oriented phrase\nSQLi: a common abbreviation for \"SQL injection\"\n\n### Relationships\nChildOf -> CWE-943\nChildOf -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** SQL injection can be resultant from special character mismanagement, MAID, or denylist/allowlist problems. It can be primary to authentication errors.\n\n\n\n### Observed Examples\n- **CVE-2023-32530:** SQL injection in security product dashboard using crafted certificate fields\n- **CVE-2021-42258:** SQL injection in time and billing software, as exploited in the wild per CISA KEV.\n- **CVE-2021-27101:** SQL injection in file-transfer system via a crafted Host header, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-138: Improper Neutralization of Special Elements\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.\n\n### Extended Description\nMost languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If product does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (\"less than\") as meaning \"read input from a file\".\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness can be related to interpretation conflicts or interaction errors in intermediaries (such as proxies or application firewalls) when the intermediary's model of an endpoint does not account for protocol-specific special elements.\n\n**[Relationship]** See this entry's children for different types of special elements that have been observed at one point or another. However, it can be difficult to find suitable CVE examples. In an attempt to be complete, CWE includes some types that do not have any associated observed example.\n\n**[Research Gap]** This weakness is probably under-studied for proprietary or custom formats. It is likely that these issues are fairly common in applications that use their own custom format for configuration files, logs, meta-data, messaging, etc. They would only be found by accident or with a focused effort based on an understanding of the format.\n\n\n\n### Observed Examples\n- **CVE-2001-0677:** Read arbitrary files from mail client by providing a special MIME header that is internally used to store pathnames for attachments.\n- **CVE-2000-0703:** Setuid program does not cleanse special escape sequence before sending data to a mail program, causing the mail program to process those sequences.\n- **CVE-2003-0020:** Multi-channel issue. Terminal escape sequences not filtered from log files.\n\n\n\n\n## CWE-352: Cross-Site Request Forgery (CSRF)\n**Abstraction:** Compound\n**Status:** Stable\n\n### Description\nThe web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.\n\n### Extended Description\nWhen a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.\n\n### Alternative Terms\nSession Riding\nCross Site Reference Forgery\nXSRF\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\nRequires -> CWE-346\nRequires -> CWE-441\nRequires -> CWE-642\nRequires -> CWE-613\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This is a well-known Composite of multiple weaknesses that must all occur simultaneously, although it is attack-oriented in nature.\n**Comments:** While attack-oriented composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine if other weaknesses allow CSRF attacks to occur, and map to those weaknesses. For example, predictable CSRF tokens might allow bypass of CSRF protection mechanisms; if this occurs, they might be better characterized as randomness/predictability weaknesses.\n**Reasons:**\n- Other\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Theoretical]** \n\nThe CSRF topology is multi-channel:\n\n\n  - Attacker (as outsider) to intermediary (as user). The interaction point is either an external or internal channel.\n\n  - Intermediary (as user) to server (as victim). The activation point is an internal channel.\n\n\n\n\n\n### Observed Examples\n- **CVE-2004-1703:** Add user accounts via a URL in an img tag\n- **CVE-2004-1995:** Add user accounts via a URL in an img tag\n- **CVE-2004-1967:** Arbitrary code execution by specifying the code in a crafted img tag or URL\n\n\n\n\n## CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product does not neutralize or incorrectly neutralizes web scripting syntax in HTTP headers that can be used by web browser components that can process raw headers, such as Flash.\n\n### Extended Description\n\n\nAn attacker may be able to conduct cross-site scripting and other attacks against users who have these components enabled.\n\n\nIf a product does not neutralize user controlled data being placed in the header of an HTTP response coming from the server, the header may contain a script that will get executed in the client's browser context, potentially resulting in a cross site scripting vulnerability or possibly an HTTP response splitting attack. It is important to carefully control data that is being placed both in HTTP response header and in the HTTP response body to ensure that no scripting syntax is present, taking various encodings into account.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-116\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2006-3918:** Web server does not remove the Expect header from an HTTP request when it is reflected back in an error message, allowing a Flash SWF file to perform XSS attacks.\n\n\n\n\n## CWE-184: Incomplete List of Disallowed Inputs\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nDenylist / Deny List: This is used by CWE and CAPEC instead of other commonly-used terms. Its counterpart is allowlist.\nBlocklist / Block List: This is often used by security tools such as firewalls, email or web gateways, proxies, etc.\nBlacklist / Black List: This term is frequently used, but usage has been declining as organizations have started to adopt other terms.\n\n### Relationships\nChildOf -> CWE-693\nChildOf -> CWE-1023\nCanPrecede -> CWE-79\nCanPrecede -> CWE-78\nCanPrecede -> CWE-434\nCanPrecede -> CWE-98\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nMultiple interpretation errors can indirectly introduce inputs that should be disallowed. For example, a list of dangerous shell metacharacters might not include a metacharacter that only has meaning in one particular shell, not all of them; or a check for XSS manipulations might ignore an unusual construct that is supported by one web browser, but not others.\n\n\n\n\n### Observed Examples\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2008-2309:** product uses a denylist to identify potentially dangerous content, allowing attacker to bypass a warning\n- **CVE-2005-2782:** PHP remote file inclusion in web application that filters \"http\" and \"https\" URLs, but not \"ftp\".\n\n\n\n\n## CWE-1287: Improper Validation of Specified Type of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.\n\n### Extended Description\n\n\nWhen input does not comply with the expected type, attackers could trigger unexpected errors, cause incorrect actions to take place, or exploit latent vulnerabilities that would not be possible if the input conformed with the expected type.\n\n\nThis weakness can appear in type-unsafe programming languages, or in programming languages that support casting or conversion of an input to another type.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nPeerOf -> CWE-843\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2008-2223:** SQL injection through an ID that was supposed to be numeric.\n\n\n\n\n## CWE-134: Use of Externally-Controlled Format String\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source.\n\n### Extended Description\n\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-668\nChildOf -> CWE-668\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any programming language that support format strings.\n\n\n**[Other]** \n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n\n\n**[Research Gap]** Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.\n\n\n\n### Observed Examples\n- **CVE-2002-1825:** format string in Perl program\n- **CVE-2001-0717:** format string in bad call to syslog function\n- **CVE-2002-0573:** format string in bad call to syslog function\n\n\n\n\n## CWE-918: Server-Side Request Forgery (SSRF)\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nXSPA: Cross Site Port Attack\nSSRF: Server-Side Request Forgery\n\n### Relationships\nChildOf -> CWE-441\nChildOf -> CWE-610\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2023-32786:** Chain: LLM integration framework has prompt injection (CWE-1427) that allows an attacker to force the service to retrieve data from an arbitrary URL, essentially providing SSRF (CWE-918) and potentially injecting content into downstream tasks.\n- **CVE-2021-26855:** Server Side Request Forgery (SSRF) in mail server, as exploited in the wild per CISA KEV.\n- **CVE-2021-21973:** Server Side Request Forgery in cloud platform, as exploited in the wild per CISA KEV.\n\n Consider specifically these CWEs: CWE-80 CWE-918 CWE-184 CWE-116 CWE-138 CWE-113 CWE-74 CWE-79",
    "cwe_mentions": [
      "CWE-80",
      "CWE-918",
      "CWE-184",
      "CWE-116",
      "CWE-138",
      "CWE-113",
      "CWE-74",
      "CWE-79"
    ],
    "search_time": 2.6134753227233887
  },
  "timestamp": "2025-03-31 07:19:03",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "79",
      "name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "494",
      "name": "Download of Code Without Integrity Check",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "434",
      "name": "Unrestricted Upload of File with Dangerous Type",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "78",
      "name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "613",
      "name": "Insufficient Session Expiration",
      "type": "base",
      "score": 4.212000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "843",
      "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
      "type": "base",
      "score": 3.757,
      "relationship_count": 0
    },
    {
      "cwe_id": "1287",
      "name": "Improper Validation of Specified Type of Input",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "352",
      "name": "Cross-Site Request Forgery (CSRF)",
      "type": "compound",
      "score": 3.542,
      "relationship_count": 0
    }
  ]
}