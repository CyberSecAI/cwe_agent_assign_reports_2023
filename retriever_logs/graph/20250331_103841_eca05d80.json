{
  "retriever": "graph",
  "query": "## Vulnerability Description\nJOSE is JSON Web Almost Everything - JWA, JWS, JWE, JWT, JWK, JWKS with no dependencies using runtimes native crypto in Node.js, Browser, Cloudflare Workers, Electron, and Deno. The PBKDF2-based JWE key management algorithms expect a JOSE Header Parameter named `p2c` PBES2 Count, which determines how many PBKDF2 iterations must be executed in order to derive a CEK wrapping key. The purpose of this parameter is to intentionally slow down the key derivation function in order to make password brute-force and dictionary attacks more expensive. This makes the PBES2 algorithms unsuitable for situations where the JWE is coming from an untrusted source an adversary can intentionally pick an extremely high PBES2 Count value, that will initiate a CPU-bound computation that may take an unreasonable amount of time to finish. Under certain conditions, it is possible to have the users environment consume unreasonable amount of CPU time. The impact is limited only to users utilizing the JWE decryption APIs with symmetric secrets to decrypt JWEs from untrusted parties who do not limit the accepted JWE Key Management Algorithms (`alg` Header Parameter) using the `keyManagementAlgorithms` (or `algorithms` in v1.x) decryption option or through other means. The `v1.28.2`, `v2.0.6`, `v3.20.4`, and `v4.9.2` releases limit the maximum PBKDF2 iteration count to `10000` by default. It is possible to adjust this limit with a newly introduced `maxPBES2Count` decryption option. If users are unable to upgrade their required library version, they have two options depending on whether they expect to receive JWEs using any of the three PBKDF2-based JWE key management algorithms. They can use the `keyManagementAlgorithms` decryption option to disable accepting PBKDF2 altogether, or they can inspect the JOSE Header prior to using the decryption API and limit the PBKDF2 iteration count (`p2c` Header Parameter).\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input validation**\n- **impact:** consume unreasonable amount of CPU time\n- **attacker:** untrusted party\n- **product:** jose\n- **version:** before v1.28.2, v2.0.6, v3.20.4, and v4.9.2\n- **component:** JWE key management algorithms\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's a breakdown of the vulnerability:\n\n**Root Cause:**\n- The vulnerability stems from the way the `jose` library handles JWE (JSON Web Encryption) decryption using PBKDF2-based key management algorithms. These algorithms use a parameter called `p2c` (PBES2 Count) to determine the number of iterations for key derivation. An attacker can specify an extremely high `p2c` value, forcing the server to perform a computationally expensive operation, leading to resource exhaustion.\n\n**Weaknesses/Vulnerabilities:**\n- **Unbounded PBKDF2 Iterations:** The library did not limit the maximum value of the `p2c` parameter, allowing for arbitrarily high iteration counts.\n- **Lack of Input Validation:** The library did not validate the `p2c` value before using it in the key derivation process.\n\n**Impact of Exploitation:**\n- **Resource Exhaustion (CPU):** An attacker can cause the server to consume excessive CPU time, potentially leading to denial of service.\n- **Slowed Decryption:** Decryption processes may become unreasonably slow or unresponsive.\n\n**Attack Vectors:**\n- **Crafted JWE:** The attacker must craft a JWE token with a high `p2c` value.\n- **Network:** The attack can be performed remotely by sending this crafted JWE to a vulnerable server.\n\n**Required Attacker Capabilities/Position:**\n- The attacker needs to be able to send JWE tokens to the vulnerable application.\n- No specific user interaction is needed.\n\n**More Detail than the CVE Description:**\n- The provided content gives a detailed explanation of how the vulnerability is triggered.\n- It explains which specific JWE key management algorithms are affected: `PBES2-HS256+A128KW`, `PBES2-HS384+A192KW`, `PBES2-HS512+A256KW`.\n- It clarifies that only users decrypting JWEs from untrusted sources with symmetric secrets, without limiting accepted JWE Key Management Algorithms, are affected.\n- It specifies the fix: limiting the maximum PBES2 iteration count to 10,000 by default, while also providing a new `maxPBES2Count` option to adjust the limit.\n- It provides workarounds for users who cannot immediately upgrade their library version: either disable PBKDF2 algorithms or inspect the JOSE header and limit the `p2c` parameter before decryption.\n- The patch includes a limit of 10,000 iterations and adds a `maxPBES2Count` option.\n- The vulnerability is network-based and can be exploited without any user interaction or special privileges.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 834 | Excessive Iteration | Class | Discouraged | sparse | 3.988 |\n| 2 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 1.470 |\n| 3 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 1.403 |\n| 4 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 1.403 |\n| 5 | 203 | Observable Discrepancy | Base | Allowed | sparse | 1.385 |\n| 6 | 335 | Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG) | Base | Allowed | dense | 0.494 |\n| 7 | 1339 | Insufficient Precision or Accuracy of a Real Number | Base | Allowed | graph | 0.002 |\n| 8 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 1.317 |\n| 9 | 1240 | Use of a Cryptographic Primitive with a Risky Implementation | Base | Allowed | sparse | 1.286 |\n| 10 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 1.267 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-834: Excessive Iteration\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.\n\n### Extended Description\nIf the iteration can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. In many cases, a loop does not need to be infinite in order to cause enough resource consumption to adversely affect the product or its host system; it depends on the amount of resources consumed per iteration.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2011-1027:** Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.\n- **CVE-2006-6499:** Chain: web browser crashes due to infinite loop - \"bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]\"\n\n\n\n\n## CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product uses a broken or risky cryptographic algorithm or protocol.\n\n### Extended Description\n\n\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts.\n\n\nIt is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected.\n\n\nSince the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.\n\n\nFor a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\nPeerOf -> CWE-311\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-30273:** SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2008-3775:** Product uses \"ROT-25\" to obfuscate the password in the registry.\n\n\n\n\n## CWE-916: Use of Password Hash With Insufficient Computational Effort\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.\n\n### Extended Description\n\n\nMany password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.\n\n\nMany hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.\n\n\nThere are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:\n\n\n  - The amount of CPU time required to compute the hash (\"stretching\")\n\n  - The amount of memory required to compute the hash (\"memory-hard\" operations)\n\n  - Including a random value, along with the password, as input to the hash computation (\"salting\")\n\n  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs (\"one-way\" hashing)\n\n  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (\"collision resistance\")\n\nNote that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-328\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2008-1526:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2006-1058:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2008-4905:** Blogging software uses a hard-coded salt when calculating a password hash.\n\n\n\n\n## CWE-347: Improper Verification of Cryptographic Signature\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not verify, or incorrectly verifies, the cryptographic signature for data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1796:** Does not properly verify signatures for \"trusted\" entities.\n- **CVE-2005-2181:** Insufficient verification allows spoofing.\n- **CVE-2005-2182:** Insufficient verification allows spoofing.\n\n\n\n\n## CWE-203: Observable Discrepancy\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.\n\n### Extended Description\nDiscrepancies can take many forms, and variations may be detectable in timing, control flow, communications such as replies or requests, or general behavior. These discrepancies can reveal information about the product's operation or internal state to an unauthorized actor. In some cases, discrepancies can be used by attackers to form a side channel.\n\n### Alternative Terms\nSide Channel Attack: Observable Discrepancies are at the root of side channel attacks.\n\n### Relationships\nChildOf -> CWE-200\nChildOf -> CWE-200\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-8695:** Observable discrepancy in the RAPL interface for some Intel processors allows information disclosure.\n- **CVE-2019-14353:** Crypto hardware wallet's power consumption relates to total number of pixels illuminated, creating a side channel in the USB connection that allows attackers to determine secrets displayed such as PIN numbers and passwords\n- **CVE-2019-10071:** Java-oriented framework compares HMAC signatures using String.equals() instead of a constant-time algorithm, causing timing discrepancies\n\n\n\n\n## CWE-335: Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a Pseudo-Random Number Generator (PRNG) but does not correctly manage seeds.\n\n### Extended Description\n\n\n PRNGs are deterministic and, while their output appears random, they cannot actually create entropy. They rely on cryptographically secure and unique seeds for entropy so proper seeding is critical to the secure operation of the PRNG.\n\n\n Management of seeds could be broken down into two main areas: \n\n\n  -  (1) protecting seeds as cryptographic material (such as a cryptographic key); \n\n  -  (2) whenever possible, using a uniquely generated seed from a cryptographically secure source \n\n PRNGs require a seed as input to generate a stream of numbers that are functionally indistinguishable from random numbers. While the output is, in many cases, sufficient for cryptographic uses, the output of any PRNG is directly determined by the seed provided as input. If the seed can be ascertained by a third party, the entire output of the PRNG can be made known to them. As such, the seed should be kept secret and should ideally not be able to be guessed. For example, the current time may be a poor seed. Knowing the approximate time the PRNG was seeded greatly reduces the possible key space. \n\n Seeds do not necessarily need to be unique, but reusing seeds may open up attacks if the seed is discovered. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-330\nChildOf -> CWE-330\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios.\n\n\n\n### Observed Examples\n- **CVE-2020-7010:** Cloud application on Kubernetes generates passwords using a weak random number generator based on deployment time.\n- **CVE-2019-11495:** server uses erlang:now() to seed the PRNG, which results in a small search space for potential random seeds\n- **CVE-2018-12520:** Product's PRNG is not seeded for the generation of session IDs\n\n\n\n\n## CWE-1339: Insufficient Precision or Accuracy of a Real Number\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product processes a real number with an implementation in which the number's representation does not preserve required accuracy and precision in its fractional part, causing an incorrect result.\n\n### Extended Description\n\n\nWhen a security decision or calculation requires highly precise, accurate numbers such as financial calculations or prices, then small variations in the number could be exploited by an attacker. \n\n\nThere are multiple ways to store the fractional part of a real number in a computer. In all of these cases, there is a limit to the accuracy of recording a fraction. If the fraction can be represented in a fixed number of digits (binary or decimal), there might not be enough digits assigned to represent the number. In other cases the number cannot be represented in a fixed number of digits due to repeating in decimal or binary notation (e.g. 0.333333...) or due to a transcendental number such as \u03a0 or \u221a2. Rounding of numbers can lead to situations where the computer results do not adequately match the result of sufficiently accurate math. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nPeerOf -> CWE-190\nCanPrecede -> CWE-834\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2018-16069:** Chain: series of floating-point precision errors (CWE-1339) in a web browser rendering engine causes out-of-bounds read (CWE-125), giving access to cross-origin data\n- **CVE-2017-7619:** Chain: rounding error in floating-point calculations (CWE-1339) in image processor leads to infinite loop (CWE-835)\n- **CVE-2021-29529:** Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)\n\n\n\n\n## CWE-1333: Inefficient Regular Expression Complexity\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.\n\n### Extended Description\nSome regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. \n\n### Alternative Terms\nReDoS: ReDoS is an abbreviation of \"Regular expression Denial of Service\".\nRegular Expression Denial of Service: While this term is attack-focused, this is commonly used to describe the weakness.\nCatastrophic backtracking: This term is used to describe the behavior of the regular expression as a negative technical impact.\n\n### Relationships\nChildOf -> CWE-407\nChildOf -> CWE-407\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n- **CVE-2021-21317:** npm package for user-agent parser prone to ReDoS due to overlapping capture groups\n- **CVE-2019-16215:** Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.\n\n\n\n\n## CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nTo fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.\n\n### Extended Description\n\n\nCryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of \"primitive\" can vary depending on point of view. See \"Terminology Notes\" for further explanation of some concepts.\n\n\nCryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time.\n\n\nIf a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is \"broken\"). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack.\n\n\nCryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered. As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly.\n\n\nIf ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences.\n\n\nThis weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** \n\n Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences.\n\n\nAs of CWE 4.6, CWE terminology around \"primitives\" and \"algorithms\" is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the \"cryptographic system\" would be AES-256-GCM with PKCS#5 formatting. The \"cryptographic function\" would be AES-256 in the GCM mode of operation, and the \"algorithm\" would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the \"cryptographic primitive,\" because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.\n\n\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2020-4778:** software uses MD5, which is less safe than the default SHA-256 used by related products\n- **CVE-2005-2946:** Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.\n- **CVE-2019-3907:** identity card uses MD5 hash of a salt and password\n\n\n\n\n## CWE-201: Insertion of Sensitive Information Into Sent Data\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe code transmits data to another actor, but a portion of the data includes sensitive information that should not be accessible to that actor.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-200\nCanAlsoBe -> CWE-209\nCanAlsoBe -> CWE-202\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Sensitive information could include data that is sensitive in and of itself (such as credentials or private messages), or otherwise useful in the further exploitation of the system (such as internal file system structure).\n\n\n\n### Observed Examples\n- **CVE-2022-0708:** Collaboration platform does not clear team emails in a response, allowing leak of email addresses\n\n Consider specifically these CWEs: CWE-916 CWE-203 CWE-834 CWE-327 CWE-335 CWE-312 CWE-1240 CWE-538 CWE-226",
  "keyphrases": {
    "original_query": "## Vulnerability Description\nJOSE is JSON Web Almost Everything - JWA, JWS, JWE, JWT, JWK, JWKS with no dependencies using runtimes native crypto in Node.js, Browser, Cloudflare Workers, Electron, and Deno. The PBKDF2-based JWE key management algorithms expect a JOSE Header Parameter named `p2c` PBES2 Count, which determines how many PBKDF2 iterations must be executed in order to derive a CEK wrapping key. The purpose of this parameter is to intentionally slow down the key derivation function in order to make password brute-force and dictionary attacks more expensive. This makes the PBES2 algorithms unsuitable for situations where the JWE is coming from an untrusted source an adversary can intentionally pick an extremely high PBES2 Count value, that will initiate a CPU-bound computation that may take an unreasonable amount of time to finish. Under certain conditions, it is possible to have the users environment consume unreasonable amount of CPU time. The impact is limited only to users utilizing the JWE decryption APIs with symmetric secrets to decrypt JWEs from untrusted parties who do not limit the accepted JWE Key Management Algorithms (`alg` Header Parameter) using the `keyManagementAlgorithms` (or `algorithms` in v1.x) decryption option or through other means. The `v1.28.2`, `v2.0.6`, `v3.20.4`, and `v4.9.2` releases limit the maximum PBKDF2 iteration count to `10000` by default. It is possible to adjust this limit with a newly introduced `maxPBES2Count` decryption option. If users are unable to upgrade their required library version, they have two options depending on whether they expect to receive JWEs using any of the three PBKDF2-based JWE key management algorithms. They can use the `keyManagementAlgorithms` decryption option to disable accepting PBKDF2 altogether, or they can inspect the JOSE Header prior to using the decryption API and limit the PBKDF2 iteration count (`p2c` Header Parameter).\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input validation**\n- **impact:** consume unreasonable amount of CPU time\n- **attacker:** untrusted party\n- **product:** jose\n- **version:** before v1.28.2, v2.0.6, v3.20.4, and v4.9.2\n- **component:** JWE key management algorithms\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's a breakdown of the vulnerability:\n\n**Root Cause:**\n- The vulnerability stems from the way the `jose` library handles JWE (JSON Web Encryption) decryption using PBKDF2-based key management algorithms. These algorithms use a parameter called `p2c` (PBES2 Count) to determine the number of iterations for key derivation. An attacker can specify an extremely high `p2c` value, forcing the server to perform a computationally expensive operation, leading to resource exhaustion.\n\n**Weaknesses/Vulnerabilities:**\n- **Unbounded PBKDF2 Iterations:** The library did not limit the maximum value of the `p2c` parameter, allowing for arbitrarily high iteration counts.\n- **Lack of Input Validation:** The library did not validate the `p2c` value before using it in the key derivation process.\n\n**Impact of Exploitation:**\n- **Resource Exhaustion (CPU):** An attacker can cause the server to consume excessive CPU time, potentially leading to denial of service.\n- **Slowed Decryption:** Decryption processes may become unreasonably slow or unresponsive.\n\n**Attack Vectors:**\n- **Crafted JWE:** The attacker must craft a JWE token with a high `p2c` value.\n- **Network:** The attack can be performed remotely by sending this crafted JWE to a vulnerable server.\n\n**Required Attacker Capabilities/Position:**\n- The attacker needs to be able to send JWE tokens to the vulnerable application.\n- No specific user interaction is needed.\n\n**More Detail than the CVE Description:**\n- The provided content gives a detailed explanation of how the vulnerability is triggered.\n- It explains which specific JWE key management algorithms are affected: `PBES2-HS256+A128KW`, `PBES2-HS384+A192KW`, `PBES2-HS512+A256KW`.\n- It clarifies that only users decrypting JWEs from untrusted sources with symmetric secrets, without limiting accepted JWE Key Management Algorithms, are affected.\n- It specifies the fix: limiting the maximum PBES2 iteration count to 10,000 by default, while also providing a new `maxPBES2Count` option to adjust the limit.\n- It provides workarounds for users who cannot immediately upgrade their library version: either disable PBKDF2 algorithms or inspect the JOSE header and limit the `p2c` parameter before decryption.\n- The patch includes a limit of 10,000 iterations and adds a `maxPBES2Count` option.\n- The vulnerability is network-based and can be exploited without any user interaction or special privileges.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 834 | Excessive Iteration | Class | Discouraged | sparse | 3.988 |\n| 2 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 1.470 |\n| 3 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 1.403 |\n| 4 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 1.403 |\n| 5 | 203 | Observable Discrepancy | Base | Allowed | sparse | 1.385 |\n| 6 | 335 | Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG) | Base | Allowed | dense | 0.494 |\n| 7 | 1339 | Insufficient Precision or Accuracy of a Real Number | Base | Allowed | graph | 0.002 |\n| 8 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 1.317 |\n| 9 | 1240 | Use of a Cryptographic Primitive with a Risky Implementation | Base | Allowed | sparse | 1.286 |\n| 10 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 1.267 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-834: Excessive Iteration\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.\n\n### Extended Description\nIf the iteration can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. In many cases, a loop does not need to be infinite in order to cause enough resource consumption to adversely affect the product or its host system; it depends on the amount of resources consumed per iteration.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2011-1027:** Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.\n- **CVE-2006-6499:** Chain: web browser crashes due to infinite loop - \"bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]\"\n\n\n\n\n## CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product uses a broken or risky cryptographic algorithm or protocol.\n\n### Extended Description\n\n\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts.\n\n\nIt is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected.\n\n\nSince the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.\n\n\nFor a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\nPeerOf -> CWE-311\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-30273:** SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2008-3775:** Product uses \"ROT-25\" to obfuscate the password in the registry.\n\n\n\n\n## CWE-916: Use of Password Hash With Insufficient Computational Effort\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.\n\n### Extended Description\n\n\nMany password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.\n\n\nMany hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.\n\n\nThere are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:\n\n\n  - The amount of CPU time required to compute the hash (\"stretching\")\n\n  - The amount of memory required to compute the hash (\"memory-hard\" operations)\n\n  - Including a random value, along with the password, as input to the hash computation (\"salting\")\n\n  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs (\"one-way\" hashing)\n\n  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (\"collision resistance\")\n\nNote that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-328\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2008-1526:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2006-1058:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2008-4905:** Blogging software uses a hard-coded salt when calculating a password hash.\n\n\n\n\n## CWE-347: Improper Verification of Cryptographic Signature\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not verify, or incorrectly verifies, the cryptographic signature for data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1796:** Does not properly verify signatures for \"trusted\" entities.\n- **CVE-2005-2181:** Insufficient verification allows spoofing.\n- **CVE-2005-2182:** Insufficient verification allows spoofing.\n\n\n\n\n## CWE-203: Observable Discrepancy\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.\n\n### Extended Description\nDiscrepancies can take many forms, and variations may be detectable in timing, control flow, communications such as replies or requests, or general behavior. These discrepancies can reveal information about the product's operation or internal state to an unauthorized actor. In some cases, discrepancies can be used by attackers to form a side channel.\n\n### Alternative Terms\nSide Channel Attack: Observable Discrepancies are at the root of side channel attacks.\n\n### Relationships\nChildOf -> CWE-200\nChildOf -> CWE-200\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-8695:** Observable discrepancy in the RAPL interface for some Intel processors allows information disclosure.\n- **CVE-2019-14353:** Crypto hardware wallet's power consumption relates to total number of pixels illuminated, creating a side channel in the USB connection that allows attackers to determine secrets displayed such as PIN numbers and passwords\n- **CVE-2019-10071:** Java-oriented framework compares HMAC signatures using String.equals() instead of a constant-time algorithm, causing timing discrepancies\n\n\n\n\n## CWE-335: Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a Pseudo-Random Number Generator (PRNG) but does not correctly manage seeds.\n\n### Extended Description\n\n\n PRNGs are deterministic and, while their output appears random, they cannot actually create entropy. They rely on cryptographically secure and unique seeds for entropy so proper seeding is critical to the secure operation of the PRNG.\n\n\n Management of seeds could be broken down into two main areas: \n\n\n  -  (1) protecting seeds as cryptographic material (such as a cryptographic key); \n\n  -  (2) whenever possible, using a uniquely generated seed from a cryptographically secure source \n\n PRNGs require a seed as input to generate a stream of numbers that are functionally indistinguishable from random numbers. While the output is, in many cases, sufficient for cryptographic uses, the output of any PRNG is directly determined by the seed provided as input. If the seed can be ascertained by a third party, the entire output of the PRNG can be made known to them. As such, the seed should be kept secret and should ideally not be able to be guessed. For example, the current time may be a poor seed. Knowing the approximate time the PRNG was seeded greatly reduces the possible key space. \n\n Seeds do not necessarily need to be unique, but reusing seeds may open up attacks if the seed is discovered. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-330\nChildOf -> CWE-330\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios.\n\n\n\n### Observed Examples\n- **CVE-2020-7010:** Cloud application on Kubernetes generates passwords using a weak random number generator based on deployment time.\n- **CVE-2019-11495:** server uses erlang:now() to seed the PRNG, which results in a small search space for potential random seeds\n- **CVE-2018-12520:** Product's PRNG is not seeded for the generation of session IDs\n\n\n\n\n## CWE-1339: Insufficient Precision or Accuracy of a Real Number\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product processes a real number with an implementation in which the number's representation does not preserve required accuracy and precision in its fractional part, causing an incorrect result.\n\n### Extended Description\n\n\nWhen a security decision or calculation requires highly precise, accurate numbers such as financial calculations or prices, then small variations in the number could be exploited by an attacker. \n\n\nThere are multiple ways to store the fractional part of a real number in a computer. In all of these cases, there is a limit to the accuracy of recording a fraction. If the fraction can be represented in a fixed number of digits (binary or decimal), there might not be enough digits assigned to represent the number. In other cases the number cannot be represented in a fixed number of digits due to repeating in decimal or binary notation (e.g. 0.333333...) or due to a transcendental number such as \u03a0 or \u221a2. Rounding of numbers can lead to situations where the computer results do not adequately match the result of sufficiently accurate math. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nPeerOf -> CWE-190\nCanPrecede -> CWE-834\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2018-16069:** Chain: series of floating-point precision errors (CWE-1339) in a web browser rendering engine causes out-of-bounds read (CWE-125), giving access to cross-origin data\n- **CVE-2017-7619:** Chain: rounding error in floating-point calculations (CWE-1339) in image processor leads to infinite loop (CWE-835)\n- **CVE-2021-29529:** Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)\n\n\n\n\n## CWE-1333: Inefficient Regular Expression Complexity\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.\n\n### Extended Description\nSome regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. \n\n### Alternative Terms\nReDoS: ReDoS is an abbreviation of \"Regular expression Denial of Service\".\nRegular Expression Denial of Service: While this term is attack-focused, this is commonly used to describe the weakness.\nCatastrophic backtracking: This term is used to describe the behavior of the regular expression as a negative technical impact.\n\n### Relationships\nChildOf -> CWE-407\nChildOf -> CWE-407\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n- **CVE-2021-21317:** npm package for user-agent parser prone to ReDoS due to overlapping capture groups\n- **CVE-2019-16215:** Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.\n\n\n\n\n## CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nTo fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.\n\n### Extended Description\n\n\nCryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of \"primitive\" can vary depending on point of view. See \"Terminology Notes\" for further explanation of some concepts.\n\n\nCryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time.\n\n\nIf a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is \"broken\"). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack.\n\n\nCryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered. As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly.\n\n\nIf ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences.\n\n\nThis weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** \n\n Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences.\n\n\nAs of CWE 4.6, CWE terminology around \"primitives\" and \"algorithms\" is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the \"cryptographic system\" would be AES-256-GCM with PKCS#5 formatting. The \"cryptographic function\" would be AES-256 in the GCM mode of operation, and the \"algorithm\" would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the \"cryptographic primitive,\" because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.\n\n\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2020-4778:** software uses MD5, which is less safe than the default SHA-256 used by related products\n- **CVE-2005-2946:** Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.\n- **CVE-2019-3907:** identity card uses MD5 hash of a salt and password\n\n\n\n\n## CWE-201: Insertion of Sensitive Information Into Sent Data\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe code transmits data to another actor, but a portion of the data includes sensitive information that should not be accessible to that actor.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-200\nCanAlsoBe -> CWE-209\nCanAlsoBe -> CWE-202\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Sensitive information could include data that is sensitive in and of itself (such as credentials or private messages), or otherwise useful in the further exploitation of the system (such as internal file system structure).\n\n\n\n### Observed Examples\n- **CVE-2022-0708:** Collaboration platform does not clear team emails in a response, allowing leak of email addresses\n\n",
    "enhanced_query": "## Vulnerability Description\nJOSE is JSON Web Almost Everything - JWA, JWS, JWE, JWT, JWK, JWKS with no dependencies using runtimes native crypto in Node.js, Browser, Cloudflare Workers, Electron, and Deno. The PBKDF2-based JWE key management algorithms expect a JOSE Header Parameter named `p2c` PBES2 Count, which determines how many PBKDF2 iterations must be executed in order to derive a CEK wrapping key. The purpose of this parameter is to intentionally slow down the key derivation function in order to make password brute-force and dictionary attacks more expensive. This makes the PBES2 algorithms unsuitable for situations where the JWE is coming from an untrusted source an adversary can intentionally pick an extremely high PBES2 Count value, that will initiate a CPU-bound computation that may take an unreasonable amount of time to finish. Under certain conditions, it is possible to have the users environment consume unreasonable amount of CPU time. The impact is limited only to users utilizing the JWE decryption APIs with symmetric secrets to decrypt JWEs from untrusted parties who do not limit the accepted JWE Key Management Algorithms (`alg` Header Parameter) using the `keyManagementAlgorithms` (or `algorithms` in v1.x) decryption option or through other means. The `v1.28.2`, `v2.0.6`, `v3.20.4`, and `v4.9.2` releases limit the maximum PBKDF2 iteration count to `10000` by default. It is possible to adjust this limit with a newly introduced `maxPBES2Count` decryption option. If users are unable to upgrade their required library version, they have two options depending on whether they expect to receive JWEs using any of the three PBKDF2-based JWE key management algorithms. They can use the `keyManagementAlgorithms` decryption option to disable accepting PBKDF2 altogether, or they can inspect the JOSE Header prior to using the decryption API and limit the PBKDF2 iteration count (`p2c` Header Parameter).\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input validation**\n- **impact:** consume unreasonable amount of CPU time\n- **attacker:** untrusted party\n- **product:** jose\n- **version:** before v1.28.2, v2.0.6, v3.20.4, and v4.9.2\n- **component:** JWE key management algorithms\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's a breakdown of the vulnerability:\n\n**Root Cause:**\n- The vulnerability stems from the way the `jose` library handles JWE (JSON Web Encryption) decryption using PBKDF2-based key management algorithms. These algorithms use a parameter called `p2c` (PBES2 Count) to determine the number of iterations for key derivation. An attacker can specify an extremely high `p2c` value, forcing the server to perform a computationally expensive operation, leading to resource exhaustion.\n\n**Weaknesses/Vulnerabilities:**\n- **Unbounded PBKDF2 Iterations:** The library did not limit the maximum value of the `p2c` parameter, allowing for arbitrarily high iteration counts.\n- **Lack of Input Validation:** The library did not validate the `p2c` value before using it in the key derivation process.\n\n**Impact of Exploitation:**\n- **Resource Exhaustion (CPU):** An attacker can cause the server to consume excessive CPU time, potentially leading to denial of service.\n- **Slowed Decryption:** Decryption processes may become unreasonably slow or unresponsive.\n\n**Attack Vectors:**\n- **Crafted JWE:** The attacker must craft a JWE token with a high `p2c` value.\n- **Network:** The attack can be performed remotely by sending this crafted JWE to a vulnerable server.\n\n**Required Attacker Capabilities/Position:**\n- The attacker needs to be able to send JWE tokens to the vulnerable application.\n- No specific user interaction is needed.\n\n**More Detail than the CVE Description:**\n- The provided content gives a detailed explanation of how the vulnerability is triggered.\n- It explains which specific JWE key management algorithms are affected: `PBES2-HS256+A128KW`, `PBES2-HS384+A192KW`, `PBES2-HS512+A256KW`.\n- It clarifies that only users decrypting JWEs from untrusted sources with symmetric secrets, without limiting accepted JWE Key Management Algorithms, are affected.\n- It specifies the fix: limiting the maximum PBES2 iteration count to 10,000 by default, while also providing a new `maxPBES2Count` option to adjust the limit.\n- It provides workarounds for users who cannot immediately upgrade their library version: either disable PBKDF2 algorithms or inspect the JOSE header and limit the `p2c` parameter before decryption.\n- The patch includes a limit of 10,000 iterations and adds a `maxPBES2Count` option.\n- The vulnerability is network-based and can be exploited without any user interaction or special privileges.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 834 | Excessive Iteration | Class | Discouraged | sparse | 3.988 |\n| 2 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 1.470 |\n| 3 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 1.403 |\n| 4 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 1.403 |\n| 5 | 203 | Observable Discrepancy | Base | Allowed | sparse | 1.385 |\n| 6 | 335 | Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG) | Base | Allowed | dense | 0.494 |\n| 7 | 1339 | Insufficient Precision or Accuracy of a Real Number | Base | Allowed | graph | 0.002 |\n| 8 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 1.317 |\n| 9 | 1240 | Use of a Cryptographic Primitive with a Risky Implementation | Base | Allowed | sparse | 1.286 |\n| 10 | 201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | sparse | 1.267 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-834: Excessive Iteration\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.\n\n### Extended Description\nIf the iteration can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. In many cases, a loop does not need to be infinite in order to cause enough resource consumption to adversely affect the product or its host system; it depends on the amount of resources consumed per iteration.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2011-1027:** Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.\n- **CVE-2006-6499:** Chain: web browser crashes due to infinite loop - \"bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]\"\n\n\n\n\n## CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product uses a broken or risky cryptographic algorithm or protocol.\n\n### Extended Description\n\n\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts.\n\n\nIt is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected.\n\n\nSince the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.\n\n\nFor a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\nPeerOf -> CWE-311\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-30273:** SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2008-3775:** Product uses \"ROT-25\" to obfuscate the password in the registry.\n\n\n\n\n## CWE-916: Use of Password Hash With Insufficient Computational Effort\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.\n\n### Extended Description\n\n\nMany password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.\n\n\nMany hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.\n\n\nThere are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:\n\n\n  - The amount of CPU time required to compute the hash (\"stretching\")\n\n  - The amount of memory required to compute the hash (\"memory-hard\" operations)\n\n  - Including a random value, along with the password, as input to the hash computation (\"salting\")\n\n  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs (\"one-way\" hashing)\n\n  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (\"collision resistance\")\n\nNote that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-328\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2008-1526:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2006-1058:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2008-4905:** Blogging software uses a hard-coded salt when calculating a password hash.\n\n\n\n\n## CWE-347: Improper Verification of Cryptographic Signature\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not verify, or incorrectly verifies, the cryptographic signature for data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1796:** Does not properly verify signatures for \"trusted\" entities.\n- **CVE-2005-2181:** Insufficient verification allows spoofing.\n- **CVE-2005-2182:** Insufficient verification allows spoofing.\n\n\n\n\n## CWE-203: Observable Discrepancy\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.\n\n### Extended Description\nDiscrepancies can take many forms, and variations may be detectable in timing, control flow, communications such as replies or requests, or general behavior. These discrepancies can reveal information about the product's operation or internal state to an unauthorized actor. In some cases, discrepancies can be used by attackers to form a side channel.\n\n### Alternative Terms\nSide Channel Attack: Observable Discrepancies are at the root of side channel attacks.\n\n### Relationships\nChildOf -> CWE-200\nChildOf -> CWE-200\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-8695:** Observable discrepancy in the RAPL interface for some Intel processors allows information disclosure.\n- **CVE-2019-14353:** Crypto hardware wallet's power consumption relates to total number of pixels illuminated, creating a side channel in the USB connection that allows attackers to determine secrets displayed such as PIN numbers and passwords\n- **CVE-2019-10071:** Java-oriented framework compares HMAC signatures using String.equals() instead of a constant-time algorithm, causing timing discrepancies\n\n\n\n\n## CWE-335: Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a Pseudo-Random Number Generator (PRNG) but does not correctly manage seeds.\n\n### Extended Description\n\n\n PRNGs are deterministic and, while their output appears random, they cannot actually create entropy. They rely on cryptographically secure and unique seeds for entropy so proper seeding is critical to the secure operation of the PRNG.\n\n\n Management of seeds could be broken down into two main areas: \n\n\n  -  (1) protecting seeds as cryptographic material (such as a cryptographic key); \n\n  -  (2) whenever possible, using a uniquely generated seed from a cryptographically secure source \n\n PRNGs require a seed as input to generate a stream of numbers that are functionally indistinguishable from random numbers. While the output is, in many cases, sufficient for cryptographic uses, the output of any PRNG is directly determined by the seed provided as input. If the seed can be ascertained by a third party, the entire output of the PRNG can be made known to them. As such, the seed should be kept secret and should ideally not be able to be guessed. For example, the current time may be a poor seed. Knowing the approximate time the PRNG was seeded greatly reduces the possible key space. \n\n Seeds do not necessarily need to be unique, but reusing seeds may open up attacks if the seed is discovered. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-330\nChildOf -> CWE-330\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios.\n\n\n\n### Observed Examples\n- **CVE-2020-7010:** Cloud application on Kubernetes generates passwords using a weak random number generator based on deployment time.\n- **CVE-2019-11495:** server uses erlang:now() to seed the PRNG, which results in a small search space for potential random seeds\n- **CVE-2018-12520:** Product's PRNG is not seeded for the generation of session IDs\n\n\n\n\n## CWE-1339: Insufficient Precision or Accuracy of a Real Number\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product processes a real number with an implementation in which the number's representation does not preserve required accuracy and precision in its fractional part, causing an incorrect result.\n\n### Extended Description\n\n\nWhen a security decision or calculation requires highly precise, accurate numbers such as financial calculations or prices, then small variations in the number could be exploited by an attacker. \n\n\nThere are multiple ways to store the fractional part of a real number in a computer. In all of these cases, there is a limit to the accuracy of recording a fraction. If the fraction can be represented in a fixed number of digits (binary or decimal), there might not be enough digits assigned to represent the number. In other cases the number cannot be represented in a fixed number of digits due to repeating in decimal or binary notation (e.g. 0.333333...) or due to a transcendental number such as \u03a0 or \u221a2. Rounding of numbers can lead to situations where the computer results do not adequately match the result of sufficiently accurate math. \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nPeerOf -> CWE-190\nCanPrecede -> CWE-834\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2018-16069:** Chain: series of floating-point precision errors (CWE-1339) in a web browser rendering engine causes out-of-bounds read (CWE-125), giving access to cross-origin data\n- **CVE-2017-7619:** Chain: rounding error in floating-point calculations (CWE-1339) in image processor leads to infinite loop (CWE-835)\n- **CVE-2021-29529:** Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)\n\n\n\n\n## CWE-1333: Inefficient Regular Expression Complexity\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.\n\n### Extended Description\nSome regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. \n\n### Alternative Terms\nReDoS: ReDoS is an abbreviation of \"Regular expression Denial of Service\".\nRegular Expression Denial of Service: While this term is attack-focused, this is commonly used to describe the weakness.\nCatastrophic backtracking: This term is used to describe the behavior of the regular expression as a negative technical impact.\n\n### Relationships\nChildOf -> CWE-407\nChildOf -> CWE-407\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n- **CVE-2021-21317:** npm package for user-agent parser prone to ReDoS due to overlapping capture groups\n- **CVE-2019-16215:** Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.\n\n\n\n\n## CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nTo fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.\n\n### Extended Description\n\n\nCryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of \"primitive\" can vary depending on point of view. See \"Terminology Notes\" for further explanation of some concepts.\n\n\nCryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time.\n\n\nIf a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is \"broken\"). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack.\n\n\nCryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered. As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly.\n\n\nIf ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences.\n\n\nThis weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** \n\n Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences.\n\n\nAs of CWE 4.6, CWE terminology around \"primitives\" and \"algorithms\" is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the \"cryptographic system\" would be AES-256-GCM with PKCS#5 formatting. The \"cryptographic function\" would be AES-256 in the GCM mode of operation, and the \"algorithm\" would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the \"cryptographic primitive,\" because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.\n\n\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2020-4778:** software uses MD5, which is less safe than the default SHA-256 used by related products\n- **CVE-2005-2946:** Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.\n- **CVE-2019-3907:** identity card uses MD5 hash of a salt and password\n\n\n\n\n## CWE-201: Insertion of Sensitive Information Into Sent Data\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe code transmits data to another actor, but a portion of the data includes sensitive information that should not be accessible to that actor.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-200\nCanAlsoBe -> CWE-209\nCanAlsoBe -> CWE-202\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Sensitive information could include data that is sensitive in and of itself (such as credentials or private messages), or otherwise useful in the further exploitation of the system (such as internal file system structure).\n\n\n\n### Observed Examples\n- **CVE-2022-0708:** Collaboration platform does not clear team emails in a response, allowing leak of email addresses\n\n Consider specifically these CWEs: CWE-916 CWE-203 CWE-834 CWE-327 CWE-335 CWE-312 CWE-1240 CWE-538 CWE-226",
    "cwe_mentions": [
      "CWE-916",
      "CWE-203",
      "CWE-834",
      "CWE-327",
      "CWE-335",
      "CWE-312",
      "CWE-1240",
      "CWE-538",
      "CWE-226"
    ],
    "search_time": 2.7905495166778564
  },
  "timestamp": "2025-03-31 10:38:41",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "1339",
      "name": "Insufficient Precision or Accuracy of a Real Number",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "201",
      "name": "Insertion of Sensitive Information Into Sent Data",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "209",
      "name": "Generation of Error Message Containing Sensitive Information",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "202",
      "name": "Exposure of Sensitive Information Through Data Queries",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "128",
      "name": "Wrap-around Error",
      "type": "base",
      "score": 3.5671999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "base",
      "score": 3.1356,
      "relationship_count": 0
    },
    {
      "cwe_id": "226",
      "name": "Sensitive Information in Resource Not Removed Before Reuse",
      "type": "Base",
      "score": 2.901834073407873,
      "relationship_count": 0
    },
    {
      "cwe_id": "1322",
      "name": "Use of Blocking Code in Single-threaded, Non-blocking Context",
      "type": "base",
      "score": 2.8651999999999997,
      "relationship_count": 0
    }
  ]
}