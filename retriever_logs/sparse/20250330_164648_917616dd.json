{
  "retriever": "sparse",
  "query": "## Vulnerability Description\nA **stack buffer overflow** vulnerability has been reported to affect QNAP device running QVR Elite, QVR Pro, QVR Guard. If exploited, this vulnerability allows attackers to execute arbitrary code. We have already fixed this vulnerability in the following versions of QVR Elite, QVR Pro, QVR Guard QuTS hero h5.0.0 QVR Elite 2.1.4.0 (2021/12/06) and later QuTS hero h4.5.4 QVR Elite 2.1.4.0 (2021/12/06) and later QTS 5.0.0 QVR Elite 2.1.4.0 (2021/12/06) and later QTS 4.5.4 QVR Elite 2.1.4.0 (2021/12/06) and later QTS 4.5.4 QVR Pro 2.1.3.0 (2021/12/06) and later QTS 5.0.0 QVR Pro 2.1.3.0 (2021/12/06) and later QTS 4.5.4 QVR Guard 2.1.3.0 (2021/12/06) and later QTS 5.0.0 QVR Guard 2.1.3.0 (2021/12/06) and later\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **stack buffer overflow**\n- **impact:** execute arbitrary code\n- **attacker:** attackers\n- **product:** QNAP device\n\n### CWE for similar CVE Descriptions\n### Primary CWE Match\nCWE-787\n\n#### Top CWEs\n- CWE-787 (Count: 25)\n\n## CVE Reference Links Content Summary\n```\n{\n  \"vulnerability_details\": {\n    \"root_cause\": \"A stack buffer overflow vulnerability\",\n    \"weaknesses\": [\n      \"Stack buffer overflow\"\n    ],\n    \"impact\": \"Allows attackers to execute arbitrary code.\",\n     \"attack_vectors\": [\n      \"The vulnerability can be exploited by sending a specially crafted input to the affected application.\"\n    ],\n    \"required_capabilities\": \"An attacker would need the ability to send a specifically crafted input to the application running on the QNAP device.\"\n  },\n  \"affected_products\": [\n    \"QNAP NAS running QVR Elite\",\n    \"QNAP NAS running QVR Pro\",\n    \"QNAP NAS running QVR Guard\"\n  ],\n    \"additional_notes\": \"The vulnerability was resolved in QVR Elite 2.1.4.0 (2021/12/06) and later, QVR Pro 2.1.3.0 (2021/12/06) and later and QVR Guard 2.1.3.0 (2021/12/06) and later. The vendor recommends updating to the latest versions of the application.\"\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |\n| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |\n| 3 | 120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | sparse | 1.946 |\n| 4 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 1.427 |\n| 5 | 77 | Improper Neutralization of Special Elements used in a Command ('Command Injection') | Class | Allowed-with-Review | sparse | 1.013 |\n| 6 | 20 | Improper Input Validation | Class | Discouraged | dense | 0.565 |\n| 7 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |\n| 8 | 23 | Relative Path Traversal | Base | Allowed | sparse | 0.714 |\n| 9 | 610 | Externally Controlled Reference to a Resource in Another Sphere | Class | Discouraged | sparse | 0.702 |\n| 10 | 287 | Improper Authentication | Class | Discouraged | sparse | 0.646 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nBuffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean \"write past the end of a buffer,\" whereas others use the same term to mean \"any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer.\" Others could mean \"any action after the end of a buffer, whether it is a read or write.\" Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.\nbuffer overrun: Some prominent vendors and researchers use the term \"buffer overrun,\" but most people use \"buffer overflow.\" See the alternate term for \"buffer overflow\" for context.\nmemory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the \"memory safety\" term.\n\n### Relationships\nChildOf -> CWE-118\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.\n**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nIt is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.\n\n\n\n\n### Observed Examples\n- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.\n- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.\n\n### Extended Description\nA buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the \"classic\" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.\n\n### Alternative Terms\nClassic Buffer Overflow: This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques.\nUnbounded Transfer\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** There are some indications that this CWE ID might be misused and selected simply because it mentions \"buffer overflow\" - an increasingly vague term. This CWE entry is only appropriate for \"Buffer Copy\" operations (not buffer reads), in which where there is no \"Checking [the] Size of Input\", and (by implication of the copy) writing past the end of the buffer.\n**Comments:** If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Relationship]** At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them.\n\n**[Terminology]** Many issues that are now called \"buffer overflows\" are substantively different than the \"classic\" overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported.\n\n\n\n### Observed Examples\n- **CVE-2000-1094:** buffer overflow using command with long argument\n- **CVE-1999-0046:** buffer overflow in local program using long environment variable\n- **CVE-2002-1337:** buffer overflow in comment characters, when product increments a counter for a \">\" but does not decrement for \"<\"\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.\n\n### Extended Description\n\n\nMany protocols and products have their own custom command language. While OS or shell command strings are frequently discovered and targeted, developers may not realize that these other command languages might also be vulnerable to attacks.\n\n\n### Alternative Terms\nCommand injection: an attack-oriented phrase for this weakness. Note: often used when \"OS command injection\" (CWE-78) was intended.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** CWE-77 is often misused when OS command injection (CWE-78) was intended instead [REF-1287].\n**Comments:** Ensure that the analysis focuses on the root-cause error that allows the execution of commands, as there are many weaknesses that can lead to this consequence. See Terminology Notes. If the weakness involves a command language besides OS shell invocation, then CWE-77 could be used.\n**Reasons:**\n- Frequent Misuse\n**Suggested Alternatives:**\n- CWE-78: OS Command Injection\n\n\n### Additional Notes\n**[Terminology]** \n\nThe \"command injection\" phrase carries different meanings, either as an attack or as a technical impact. The most common usage of \"command injection\" refers to the more-accurate OS command injection (CWE-78), but there are many command languages.\n\n\nIn vulnerability-focused analysis, the phrase may refer to any situation in which the adversary can execute commands of their own choosing, i.e., the focus is on the risk and/or technical impact of exploitation. Many proof-of-concept exploits focus on the ability to execute commands and may emphasize \"command injection.\" However, there are dozens of weaknesses that can allow execution of commands. That is, the ability to execute commands could be resultant from another weakness.\n\n\nTo some, \"command injection\" can include cases in which the functionality intentionally allows the user to specify an entire command, which is then executed. In this case, the root cause weakness might be related to missing or incorrect authorization, since an adversary should not be able to specify arbitrary commands, but some users or admins are allowed.\n\n\nCWE-77 and its descendants are specifically focused on behaviors in which the product is intentionally building a command to execute, and the adversary can inject separators into the command or otherwise change the command being executed.\n\n\n**[Other]** \n\nCommand injection is a common problem with wrapper programs.\n\n\n\n\n### Observed Examples\n- **CVE-2022-1509:** injection of sed script syntax (\"sed injection\")\n- **CVE-2024-5184:** API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.\n- **CVE-2020-11698:** anti-spam product allows injection of SNMP commands into confiuration file\n\n\n\n\n## CWE-20: Improper Input Validation\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.\n\n### Extended Description\n\n\nInput validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.\n\n\nInput validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.)\n\n\nInput validation can be applied to:\n\n\n  - raw data - strings, numbers, parameters, file contents, etc.\n\n  - metadata - information about the raw data, such as headers or size\n\nData can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data.\n\nMany properties of raw data or metadata may need to be validated upon entry into the code, such as:\n\n\n  - specified quantities such as size, length, frequency, price, rate, number of operations, time, etc.\n\n  - implied or derived quantities, such as the actual size of a file instead of a specified size\n\n  - indexes, offsets, or positions into more complex data structures\n\n  - symbolic keys or other elements into hash tables, associative arrays, etc.\n\n  - well-formedness, i.e. syntactic correctness - compliance with expected syntax \n\n  - lexical token correctness - compliance with rules for what is treated as a token\n\n  - specified or derived type - the actual type of the input (or what the input appears to be)\n\n  - consistency - between individual data elements, between raw data and metadata, between references, etc.\n\n  - conformance to domain-specific rules, e.g. business logic \n\n  - equivalence - ensuring that equivalent inputs are treated the same\n\n  - authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data\n\nImplied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. \n\nNote that \"input validation\" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation.\n\n\nFinally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\nPeerOf -> CWE-345\nCanPrecede -> CWE-22\nCanPrecede -> CWE-41\nCanPrecede -> CWE-74\nCanPrecede -> CWE-119\nCanPrecede -> CWE-770\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-20 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available [REF-1287]. It is not useful for trend analysis. It is also a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Consider lower-level children such as Improper Use of Validation Framework (CWE-1173) or improper validation involving specific types or properties of input such as Specified Quantity (CWE-1284); Specified Index, Position, or Offset (CWE-1285); Syntactic Correctness (CWE-1286); Specified Type (CWE-1287); Consistency within Input (CWE-1288); or Unsafe Equivalence (CWE-1289).\n**Reasons:**\n- Frequent Misuse\n**Suggested Alternatives:**\n- CWE-1284: Specified Quantity\n- CWE-1285: Specified Index, Position, or Offset\n- CWE-1286: Syntactic Correctness\n- CWE-1287: Specified Type\n- CWE-1288: Consistency within Input\n- CWE-1289: Unsafe Equivalence\n- CWE-116: Improper Encoding or Escaping of Output\n\n\n### Additional Notes\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\n**[Maintenance]** As of 2020, this entry is used more often than preferred, and it is a source of frequent confusion. It is being actively modified for CWE 4.1 and subsequent versions.\n\n**[Maintenance]** Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document.\n\n**[Maintenance]** Input validation - whether missing or incorrect - is such an essential and widespread part of secure development that it is implicit in many different weaknesses. Traditionally, problems such as buffer overflows and XSS have been classified as input validation problems by many security professionals. However, input validation is not necessarily the only protection mechanism available for avoiding such problems, and in some cases it is not even sufficient. The CWE team has begun capturing these subtleties in chains within the Research Concepts view (CWE-1000), but more work is needed.\n\n**[Terminology]** \n\nThe \"input validation\" term is extremely common, but it is used in many different ways. In some cases its usage can obscure the real underlying weakness or otherwise hide chaining and composite relationships.\n\n\nSome people use \"input validation\" as a general term that covers many different neutralization techniques for ensuring that input is appropriate, such as filtering, canonicalization, and escaping. Others use the term in a more narrow context to simply mean \"checking if an input conforms to expectations without changing it.\" CWE uses this more narrow interpretation.\n\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2021-30860:** Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-128: Wrap-around Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nWrap around errors occur whenever a value is incremented past the maximum value for its type and therefore \"wraps around\" to a very small, negative, or undefined value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nCanPrecede -> CWE-119\nPeerOf -> CWE-190\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** The relationship between overflow and wrap-around needs to be examined more closely, since several entries (including CWE-190) are closely related.\n\n\n\n\n\n\n## CWE-23: Relative Path Traversal\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as \"..\" that can resolve to a location that is outside of that directory.\n\n### Extended Description\nThis allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.\n\n### Alternative Terms\nZip Slip: \"Zip slip\" is an attack that uses file archives (e.g., ZIP, tar, rar, etc.) that contain filenames with path traversal sequences that cause the files to be written outside of the directory under which the archive is expected to be extracted [REF-1282]. It is most commonly used for relative path traversal (CWE-23) and link following (CWE-59).\n\n### Relationships\nChildOf -> CWE-22\nChildOf -> CWE-22\nChildOf -> CWE-22\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2019-20916:** Python package manager does not correctly restrict the filename specified in a Content-Disposition header, allowing arbitrary file read using path traversal sequences such as \"../\"\n\n\n\n\n## CWE-610: Externally Controlled Reference to a Resource in Another Sphere\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product uses an externally controlled name or reference that resolves to a resource that is outside of the intended control sphere.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This is a general class of weakness, but most research is focused on more specialized cases, such as path traversal (CWE-22) and symlink following (CWE-61). A symbolic link has a name; in general, it appears like any other file in the file system. However, the link includes a reference to another file, often in another directory - perhaps in another sphere of control. Many common library functions that accept filenames will \"follow\" a symbolic link and use the link's target instead.\n\n**[Maintenance]** The relationship between CWE-99 and CWE-610 needs further investigation and clarification. They might be duplicates. CWE-99 \"Resource Injection,\" as originally defined in Seven Pernicious Kingdoms taxonomy, emphasizes the \"identifier used to access a system resource\" such as a file name or port number, yet it explicitly states that the \"resource injection\" term does not apply to \"path manipulation,\" which effectively identifies the path at which a resource can be found and could be considered to be one aspect of a resource identifier. Also, CWE-610 effectively covers any type of resource, whether that resource is at the system layer, the application layer, or the code layer.\n\n\n\n### Observed Examples\n- **CVE-2022-3032:** An email client does not block loading of remote objects in a nested document.\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2018-1000613:** Cryptography API uses unsafe reflection when deserializing a private key\n\n\n\n\n## CWE-287: Improper Authentication\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nWhen an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nauthentification: An alternate term is \"authentification\", which appears to be most commonly used by people from non-English-speaking countries.\nAuthN: \"AuthN\" is typically used as an abbreviation of \"authentication\" within the web application security community. It is also distinct from \"AuthZ,\" which is an abbreviation of \"authorization.\" The use of \"Auth\" as an abbreviation is discouraged, since it could be used for either authentication or authorization.\nAuthC: \"AuthC\" is used as an abbreviation of \"authentication,\" but it appears to used less frequently than \"AuthN.\"\n\n### Relationships\nChildOf -> CWE-284\nChildOf -> CWE-284\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry might be misused when lower-level CWE entries are likely to be applicable. It is a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Consider children or descendants, beginning with CWE-1390: Weak Authentication or CWE-306: Missing Authentication for Critical Function.\n**Reasons:**\n- Frequent Misuse\n**Suggested Alternatives:**\n- CWE-1390: Weak Authentication\n- CWE-306: Missing Authentication for Critical Function\n\n\n### Additional Notes\n**[Relationship]** This can be resultant from SQL injection vulnerabilities and other issues.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-35248:** Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication\n- **CVE-2022-36436:** Python-based authentication proxy does not enforce password authentication during the initial handshake, allowing the client to bypass authentication by specifying a 'None' authentication type.\n- **CVE-2022-30034:** Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).\n\n",
  "keyphrases": {},
  "timestamp": "2025-03-30 16:46:48",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 8348.195914560096,
      "search_source": "base_query"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 7846.714601288237,
      "search_source": "base_query"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 7816.644509514515,
      "search_source": "base_query"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "score": 7772.488078100948,
      "search_source": "base_query"
    },
    {
      "cwe_id": "120",
      "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
      "score": 7699.7624923974345,
      "search_source": "base_query"
    }
  ]
}