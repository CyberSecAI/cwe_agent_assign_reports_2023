{
  "retriever": "sparse",
  "query": "## Vulnerability Description\nHyperledger Fabric 2.3 allows attackers to cause a denial of service (orderer crash) by repeatedly sending a crafted channel tx with the same Channel name. NOTE the official Fabric with Raft prevents exploitation via a locking mechanism and a check for names that already exist.\n\n### Vulnerability Description Key Phrases\n- **impact:** denial of service\n- **vector:** crafted channel tx with the same Channel name\n- **attacker:** attackers\n- **product:** Hyperledger Fabric\n- **version:** 2.3\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's an analysis of the vulnerability described:\n\n**Root Cause of Vulnerability:**\n\nThe root cause is a race condition during channel creation in Hyperledger Fabric's orderer component, specifically when using the Raft consensus protocol. If a channel creation transaction is not fully processed and marked as complete in the Write-Ahead Log (WAL) due to a crash or other failure, the orderer might attempt to recreate the channel upon restart. The issue arises because the orderer attempts to create a new channel even if a chain with the same name already exists.\n\n**Weaknesses/Vulnerabilities Present:**\n\n*   **Lack of proper synchronization:** The code did not have a mechanism to prevent the creation of duplicate channels if a previous attempt had failed but left some artifacts in the system.\n*   **Missing existence check:** The code lacked a check to ensure that a channel of type `etcdraft.Chain` with the same name doesn't already exist in the map of chains, before attempting to create a new one.\n*   **Panic on failure**: When a channel already exists, the system panics rather than handling it gracefully.\n\n**Impact of Exploitation:**\n\n*   **Orderer crash:** The primary impact is that the orderer node crashes due to a panic. This prevents the orderer from functioning correctly and disrupts the network's ability to process transactions.\n*   **Denial of Service:** Repeatedly sending fuzzed channel creation transactions can lead to a denial-of-service condition by repeatedly crashing the orderer nodes.\n*   **Chain corruption:** Though not explicitly stated, inconsistent state can occur when creating duplicate chains due to the lack of proper locking during channel creation and removal.\n\n**Attack Vectors:**\n\n*   **Fuzzed channel creation transactions:** The vulnerability is triggered by sending malformed channel creation transactions, specifically with the same channel name.\n*   **Network disruption:** A malicious actor can send these malformed transactions to cause orderer crashes.\n\n**Required Attacker Capabilities/Position:**\n\n*   **Ability to submit transactions:** The attacker needs the ability to submit transactions to the Hyperledger Fabric network.\n*   **Knowledge of the vulnerability:** The attacker needs to be aware that sending duplicate channel creation transactions can crash orderers.\n\n**Additional Notes:**\n\n*   The fix involves adding a check to see if the chain already exists and also adding a lock when halting and deleting a chain.\n*   The original issue was identified by fuzzing the channel creation transaction.\n*   This issue is fixed in Hyperledger Fabric by pull request #2934, which introduces a check and locking mechanism to prevent duplicate chain creation.\n\nThis information is more detailed than a basic CVE description, providing insight into the specific code vulnerability and how to exploit it.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 670 | Always-Incorrect Control Flow Implementation | Class | Allowed-with-Review | sparse | 0.165 |\n| 2 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 0.081 |\n| 3 | 755 | Improper Handling of Exceptional Conditions | Class | Discouraged | sparse | 0.077 |\n| 4 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.077 |\n| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.077 |\n| 6 | 1317 | Improper Access Control in Fabric Bridge | Base | Allowed | dense | 0.479 |\n| 7 | 476 | NULL Pointer Dereference | Base | Allowed | graph | 0.002 |\n| 8 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.076 |\n| 9 | 696 | Incorrect Behavior Order | Class | Allowed-with-Review | sparse | 0.075 |\n| 10 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.074 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-670: Always-Incorrect Control Flow Implementation\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe code contains a control flow path that does not reflect the algorithm that the path is intended to implement, leading to incorrect behavior any time this path is navigated.\n\n### Extended Description\nThis weakness captures cases in which a particular code segment is always incorrect with respect to the algorithm that it is implementing. For example, if a C programmer intends to include multiple statements in a single block but does not include the enclosing braces (CWE-483), then the logic is always incorrect. This issue is in contrast to most weaknesses in which the code usually behaves correctly, except when it is externally manipulated in malicious ways.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** This node could possibly be split into lower-level nodes. \"Early Return\" is for returning control to the caller too soon (e.g., CWE-584). \"Excess Return\" is when control is returned too far up the call stack (CWE-600, CWE-395). \"Improper control limitation\" occurs when the product maintains control at a lower level of execution, when control should be returned \"further\" up the call stack (CWE-455). \"Incorrect syntax\" covers code that's \"just plain wrong\" such as CWE-484 and CWE-483.\n\n\n\n### Observed Examples\n- **CVE-2021-3011:** virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code\n\n\n\n\n## CWE-754: Improper Check for Unusual or Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.\n\n### Extended Description\n\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\nCanPrecede -> CWE-416\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.\n- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.\n\n\n\n\n## CWE-755: Improper Handling of Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not handle or incorrectly handles an exceptional condition.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2023-41151:** SDK for OPC Unified Architecture (OPC UA) server has uncaught exception when a socket is blocked for writing but the server tries to send an error\n- **[REF-1374]:** Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)\n- **CVE-2021-3011:** virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code\n\n\n\n\n## CWE-667: Improper Locking\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.\n\n### Extended Description\n\n\nLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.\n\n\n\n### Observed Examples\n- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.\n- **CVE-2009-0935:** Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice\n- **CVE-2010-4210:** function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.\n\n\n\n\n## CWE-770: Allocation of Resources Without Limits or Throttling\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.\n\n### Extended Description\n\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-400\nChildOf -> CWE-665\nChildOf -> CWE-400\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771).\n\n**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2009-4017:** Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..\n- **CVE-2009-2726:** Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.\n\n\n\n\n## CWE-1317: Improper Access Control in Fabric Bridge\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a fabric bridge for transactions between two Intellectual Property (IP) blocks, but the bridge does not properly perform the expected privilege, identity, or other access control checks between those IP blocks.\n\n### Extended Description\n\n\nIn hardware designs, different IP blocks are connected through interconnect-bus fabrics (e.g. AHB and OCP). Within a System on Chip (SoC), the IP block subsystems could be using different bus protocols. In such a case, the IP blocks are then linked to the central bus (and to other IP blocks) through a fabric bridge. Bridges are used as bus-interconnect-routing modules that link different protocols or separate, different segments of the overall SoC interconnect.\n\n\nFor overall system security, it is important that the access-control privileges associated with any fabric transaction are consistently maintained and applied, even when they are routed or translated by a fabric bridge. A bridge that is connected to a fabric without security features forwards transactions to the slave without checking the privilege level of the master and results in a weakness in SoC access-control security. The same weakness occurs if a bridge does not check the hardware identity of the transaction received from the slave interface of the bridge.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-284\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2019-6260:** Baseboard Management Controller (BMC) device implements Advanced High-performance Bus (AHB) bridges that do not require authentication for arbitrary read and write access to the BMC's physical address space from the host, and possibly the network [REF-1138].\n\n\n\n\n## CWE-476: NULL Pointer Dereference\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product dereferences a pointer that it expects to be valid but is NULL.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNPD: Common abbreviation for Null Pointer Dereference\nnull deref: Common abbreviation for Null Pointer Dereference\nNPE: Common abbreviation for Null Pointer Exception\nnil pointer dereference: used for access of nil in Go programs\n\n### Relationships\nChildOf -> CWE-710\nChildOf -> CWE-754\nChildOf -> CWE-754\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2005-3274:** race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.\n- **CVE-2002-1912:** large number of packets leads to NULL dereference\n- **CVE-2005-0772:** packet with invalid error status value triggers NULL dereference\n\n\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-696: Incorrect Behavior Order\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product performs multiple related behaviors, but the behaviors are performed in the wrong order in ways which may produce resultant weaknesses.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2019-9805:** Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.\n- **CVE-2007-5191:** file-system management programs call the setuid and setgid functions in the wrong order and do not check the return values, allowing attackers to gain unintended privileges\n- **CVE-2007-1588:** C++ web server program calls Process::setuid before calling Process::setgid, preventing it from dropping privileges, potentially allowing CGI programs to be called with higher privileges than intended\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\nHyperledger Fabric 2.3 allows attackers to cause a denial of service (orderer crash) by repeatedly sending a crafted channel tx with the same Channel name. NOTE the official Fabric with Raft prevents exploitation via a locking mechanism and a check for names that already exist.\n\n### Vulnerability Description Key Phrases\n- **impact:** denial of service\n- **vector:** crafted channel tx with the same Channel name\n- **attacker:** attackers\n- **product:** Hyperledger Fabric\n- **version:** 2.3\n\n## CVE Reference Links Content Summary\nBased on the provided content, here's an analysis of the vulnerability described:\n\n**Root Cause of Vulnerability:**\n\nThe root cause is a race condition during channel creation in Hyperledger Fabric's orderer component, specifically when using the Raft consensus protocol. If a channel creation transaction is not fully processed and marked as complete in the Write-Ahead Log (WAL) due to a crash or other failure, the orderer might attempt to recreate the channel upon restart. The issue arises because the orderer attempts to create a new channel even if a chain with the same name already exists.\n\n**Weaknesses/Vulnerabilities Present:**\n\n*   **Lack of proper synchronization:** The code did not have a mechanism to prevent the creation of duplicate channels if a previous attempt had failed but left some artifacts in the system.\n*   **Missing existence check:** The code lacked a check to ensure that a channel of type `etcdraft.Chain` with the same name doesn't already exist in the map of chains, before attempting to create a new one.\n*   **Panic on failure**: When a channel already exists, the system panics rather than handling it gracefully.\n\n**Impact of Exploitation:**\n\n*   **Orderer crash:** The primary impact is that the orderer node crashes due to a panic. This prevents the orderer from functioning correctly and disrupts the network's ability to process transactions.\n*   **Denial of Service:** Repeatedly sending fuzzed channel creation transactions can lead to a denial-of-service condition by repeatedly crashing the orderer nodes.\n*   **Chain corruption:** Though not explicitly stated, inconsistent state can occur when creating duplicate chains due to the lack of proper locking during channel creation and removal.\n\n**Attack Vectors:**\n\n*   **Fuzzed channel creation transactions:** The vulnerability is triggered by sending malformed channel creation transactions, specifically with the same channel name.\n*   **Network disruption:** A malicious actor can send these malformed transactions to cause orderer crashes.\n\n**Required Attacker Capabilities/Position:**\n\n*   **Ability to submit transactions:** The attacker needs the ability to submit transactions to the Hyperledger Fabric network.\n*   **Knowledge of the vulnerability:** The attacker needs to be aware that sending duplicate channel creation transactions can crash orderers.\n\n**Additional Notes:**\n\n*   The fix involves adding a check to see if the chain already exists and also adding a lock when halting and deleting a chain.\n*   The original issue was identified by fuzzing the channel creation transaction.\n*   This issue is fixed in Hyperledger Fabric by pull request #2934, which introduces a check and locking mechanism to prevent duplicate chain creation.\n\nThis information is more detailed than a basic CVE description, providing insight into the specific code vulnerability and how to exploit it.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 670 | Always-Incorrect Control Flow Implementation | Class | Allowed-with-Review | sparse | 0.165 |\n| 2 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 0.081 |\n| 3 | 755 | Improper Handling of Exceptional Conditions | Class | Discouraged | sparse | 0.077 |\n| 4 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.077 |\n| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.077 |\n| 6 | 1317 | Improper Access Control in Fabric Bridge | Base | Allowed | dense | 0.479 |\n| 7 | 476 | NULL Pointer Dereference | Base | Allowed | graph | 0.002 |\n| 8 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.076 |\n| 9 | 696 | Incorrect Behavior Order | Class | Allowed-with-Review | sparse | 0.075 |\n| 10 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.074 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-670: Always-Incorrect Control Flow Implementation\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe code contains a control flow path that does not reflect the algorithm that the path is intended to implement, leading to incorrect behavior any time this path is navigated.\n\n### Extended Description\nThis weakness captures cases in which a particular code segment is always incorrect with respect to the algorithm that it is implementing. For example, if a C programmer intends to include multiple statements in a single block but does not include the enclosing braces (CWE-483), then the logic is always incorrect. This issue is in contrast to most weaknesses in which the code usually behaves correctly, except when it is externally manipulated in malicious ways.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** This node could possibly be split into lower-level nodes. \"Early Return\" is for returning control to the caller too soon (e.g., CWE-584). \"Excess Return\" is when control is returned too far up the call stack (CWE-600, CWE-395). \"Improper control limitation\" occurs when the product maintains control at a lower level of execution, when control should be returned \"further\" up the call stack (CWE-455). \"Incorrect syntax\" covers code that's \"just plain wrong\" such as CWE-484 and CWE-483.\n\n\n\n### Observed Examples\n- **CVE-2021-3011:** virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code\n\n\n\n\n## CWE-754: Improper Check for Unusual or Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.\n\n### Extended Description\n\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\nCanPrecede -> CWE-416\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.\n- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.\n\n\n\n\n## CWE-755: Improper Handling of Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not handle or incorrectly handles an exceptional condition.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2023-41151:** SDK for OPC Unified Architecture (OPC UA) server has uncaught exception when a socket is blocked for writing but the server tries to send an error\n- **[REF-1374]:** Chain: JavaScript-based cryptocurrency library can fall back to the insecure Math.random() function instead of reporting a failure (CWE-392), thus reducing the entropy (CWE-332) and leading to generation of non-unique cryptographic keys for Bitcoin wallets (CWE-1391)\n- **CVE-2021-3011:** virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code\n\n\n\n\n## CWE-667: Improper Locking\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.\n\n### Extended Description\n\n\nLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.\n\n\n\n### Observed Examples\n- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.\n- **CVE-2009-0935:** Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice\n- **CVE-2010-4210:** function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.\n\n\n\n\n## CWE-770: Allocation of Resources Without Limits or Throttling\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.\n\n### Extended Description\n\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-400\nChildOf -> CWE-665\nChildOf -> CWE-400\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771).\n\n**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2009-4017:** Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..\n- **CVE-2009-2726:** Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.\n\n\n\n\n## CWE-1317: Improper Access Control in Fabric Bridge\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a fabric bridge for transactions between two Intellectual Property (IP) blocks, but the bridge does not properly perform the expected privilege, identity, or other access control checks between those IP blocks.\n\n### Extended Description\n\n\nIn hardware designs, different IP blocks are connected through interconnect-bus fabrics (e.g. AHB and OCP). Within a System on Chip (SoC), the IP block subsystems could be using different bus protocols. In such a case, the IP blocks are then linked to the central bus (and to other IP blocks) through a fabric bridge. Bridges are used as bus-interconnect-routing modules that link different protocols or separate, different segments of the overall SoC interconnect.\n\n\nFor overall system security, it is important that the access-control privileges associated with any fabric transaction are consistently maintained and applied, even when they are routed or translated by a fabric bridge. A bridge that is connected to a fabric without security features forwards transactions to the slave without checking the privilege level of the master and results in a weakness in SoC access-control security. The same weakness occurs if a bridge does not check the hardware identity of the transaction received from the slave interface of the bridge.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-284\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2019-6260:** Baseboard Management Controller (BMC) device implements Advanced High-performance Bus (AHB) bridges that do not require authentication for arbitrary read and write access to the BMC's physical address space from the host, and possibly the network [REF-1138].\n\n\n\n\n## CWE-476: NULL Pointer Dereference\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product dereferences a pointer that it expects to be valid but is NULL.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNPD: Common abbreviation for Null Pointer Dereference\nnull deref: Common abbreviation for Null Pointer Dereference\nNPE: Common abbreviation for Null Pointer Exception\nnil pointer dereference: used for access of nil in Go programs\n\n### Relationships\nChildOf -> CWE-710\nChildOf -> CWE-754\nChildOf -> CWE-754\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2005-3274:** race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.\n- **CVE-2002-1912:** large number of packets leads to NULL dereference\n- **CVE-2005-0772:** packet with invalid error status value triggers NULL dereference\n\n\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-696: Incorrect Behavior Order\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product performs multiple related behaviors, but the behaviors are performed in the wrong order in ways which may produce resultant weaknesses.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2019-9805:** Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.\n- **CVE-2007-5191:** file-system management programs call the setuid and setgid functions in the wrong order and do not check the return values, allowing attackers to gain unintended privileges\n- **CVE-2007-1588:** C++ web server program calls Process::setuid before calling Process::setgid, preventing it from dropping privileges, potentially allowing CGI programs to be called with higher privileges than intended\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n"
  },
  "timestamp": "2025-03-31 10:13:45",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "754",
      "name": "Improper Check for Unusual or Exceptional Conditions",
      "score": 5364.647857749779,
      "search_source": "unknown"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 5130.213675028083,
      "search_source": "unknown"
    },
    {
      "cwe_id": "252",
      "name": "Unchecked Return Value",
      "score": 5128.586237939146,
      "search_source": "unknown"
    },
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 5112.404669672548,
      "search_source": "unknown"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 5068.736663033844,
      "search_source": "unknown"
    }
  ]
}