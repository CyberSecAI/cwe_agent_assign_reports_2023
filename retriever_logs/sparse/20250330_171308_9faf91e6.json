{
  "retriever": "sparse",
  "query": "## Vulnerability Description\n**URL encoding error in development mode handler** in com.vaadinflow-server versions 2.0.0 through 2.6.1 (Vaadin 14.0.0 through 14.6.1), 3.0.0 through 6.0.9 (Vaadin 15.0.0 through 19.0.8) allows local user to execute arbitrary JavaScript code by opening crafted URL in browser.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **URL encoding error in development mode handler**\n- **impact:** execute arbitrary JavaScript code\n- **vector:** opening crafted URL in browser\n- **attacker:** local user\n- **product:** com.vaadinflow-server\n- **version:** 2.0.0 through 2.6.1, 3.0.0 through 6.0.9\n\n## CVE Reference Links Content Summary\nBased on the provided information, here's an analysis of CVE-2021-33604:\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from a URL encoding error in the development mode handler of Vaadin Flow server. Specifically, the webpack dev-server does not escape the `\"` character, which is not a valid URL character, and this limitation was not being checked when requests were passed to it via `DevModeHandlerImpl`.\n\n**Weaknesses/Vulnerabilities Present:**\n*   **Improper URL Sanitization:** The application fails to properly sanitize URLs before passing them to the webpack dev server.\n*   **Reflected Cross-Site Scripting (XSS):** The lack of proper encoding allows an attacker to inject malicious JavaScript code into the URL, which is then reflected back and executed within the context of the user's browser.\n\n**Impact of Exploitation:**\n*   **Arbitrary JavaScript Execution:** An attacker can execute arbitrary JavaScript code within the developer's browser by tricking them into opening a malicious URL.\n*   **Access to Local Vaadin Application:** If the developer has a Vaadin application running locally with sensitive data (e.g., a clone of a production database), the attacker could potentially gain access to it and its data.\n*   **Data Exfiltration:** Attackers could potentially exfiltrate the sensitive data from the local development environment.\n\n**Attack Vectors:**\n*   **Crafted URL:** The attacker crafts a malicious URL containing JavaScript code that is not properly encoded.\n*   **External Website:** The developer is tricked into opening an external website that contains the malicious URL which in turn gets the XSS attack going.\n*   **Local User as Victim**: The attack targets a developer who has a local Vaadin application running with the frontend development server enabled.\n\n**Required Attacker Capabilities/Position:**\n*   **Awareness of Target:** The attacker must be aware of the specific Vaadin application running on the developer's system, including the Vaadin version and the data it exposes.\n*   **Ability to Create and Host Malicious Website:** The attacker needs to be able to create and host a web page or send the crafted URL directly to the victim.\n*   **Ability to Lure the Victim:** The attacker must be able to trick the developer into opening the crafted URL.\n\n**Additional Notes:**\n\n*   The vulnerability is only exploitable during development time on the developer's machine, not in deployed applications.\n*   The vulnerability was fixed by implementing proper URL sanitization and encoding for requests to the webpack dev-server.\n\n**Versions Affected:**\n*   `com.vaadin:flow-server` versions 2.0.0 through 2.6.1 (Vaadin 14.0.0 through 14.6.1)\n*   `com.vaadin:flow-server` versions 3.0.0 through 6.0.9 (Vaadin 15.0.0 through 19.0.8)\n\n**Versions Fixed:**\n*   `com.vaadin:flow-server` version 2.6.2 and later (for Vaadin 14)\n*   `com.vaadin:flow-server` version 6.0.10 and later (for Vaadin 19)\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 177 | Improper Handling of URL Encoding (Hex Encoding) | Variant | Allowed | sparse | 0.449 |\n| 2 | 1295 | Debug Messages Revealing Unnecessary Information | Base | Allowed | sparse | 0.305 |\n| 3 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.285 |\n| 4 | 208 | Observable Timing Discrepancy | Base | Allowed | sparse | 0.285 |\n| 5 | 116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | sparse | 0.285 |\n| 6 | 84 | Improper Neutralization of Encoded URI Schemes in a Web Page | Variant | Allowed | dense | 0.539 |\n| 7 | 385 | Covert Timing Channel | Base | Allowed | graph | 0.002 |\n| 8 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.267 |\n| 9 | 113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | sparse | 0.249 |\n| 10 | 918 | Server-Side Request Forgery (SSRF) | Base | Allowed | sparse | 0.248 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not properly handle when all or part of an input has been URL encoded.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-172\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2000-0900:** Hex-encoded path traversal variants - \"%2e%2e\", \"%2e%2e%2f\", \"%5c%2e%2e\"\n- **CVE-2005-2256:** Hex-encoded path traversal variants - \"%2e%2e\", \"%2e%2e%2f\", \"%5c%2e%2e\"\n- **CVE-2004-2121:** Hex-encoded path traversal variants - \"%2e%2e\", \"%2e%2e%2f\", \"%5c%2e%2e\"\n\n\n\n\n## CWE-1295: Debug Messages Revealing Unnecessary Information\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product fails to adequately prevent the revealing of unnecessary and potentially sensitive system information within debugging messages.\n\n### Extended Description\n\n\nDebug messages are messages that help troubleshoot an issue by revealing the internal state of the system. For example, debug data in design can be exposed through internal memory array dumps or boot logs through interfaces like UART via TAP commands, scan chain, etc. Thus, the more information contained in a debug message, the easier it is to debug. However, there is also the risk of revealing information that could help an attacker either decipher a vulnerability, and/or gain a better understanding of the system. Thus, this extra information could lower the \"security by obscurity\" factor. While \"security by obscurity\" alone is insufficient, it can help as a part of \"Defense-in-depth\". \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-200\nPeerOf -> CWE-209\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2021-25476:** Digital Rights Management (DRM) capability for mobile platform leaks pointer information, simplifying ASLR bypass\n- **CVE-2020-24491:** Processor generates debug message that contains sensitive information (\"addresses of memory transactions\").\n- **CVE-2017-18326:** modem debug messages include cryptographic keys\n\n\n\n\n## CWE-1333: Inefficient Regular Expression Complexity\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.\n\n### Extended Description\nSome regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. \n\n### Alternative Terms\nReDoS: ReDoS is an abbreviation of \"Regular expression Denial of Service\".\nRegular Expression Denial of Service: While this term is attack-focused, this is commonly used to describe the weakness.\nCatastrophic backtracking: This term is used to describe the behavior of the regular expression as a negative technical impact.\n\n### Relationships\nChildOf -> CWE-407\nChildOf -> CWE-407\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n- **CVE-2021-21317:** npm package for user-agent parser prone to ReDoS due to overlapping capture groups\n- **CVE-2019-16215:** Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.\n\n\n\n\n## CWE-208: Observable Timing Discrepancy\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTwo separate operations in a product require different amounts of time to complete, in a way that is observable to an actor and reveals security-relevant information about the state of the product, such as whether a particular operation was successful or not.\n\n### Extended Description\nIn security-relevant contexts, even small variations in timing can be exploited by attackers to indirectly infer certain details about the product's internal operations. For example, in some cryptographic algorithms, attackers can use timing differences to infer certain properties about a private key, making the key easier to guess. Timing discrepancies effectively form a timing side channel.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-203\nCanPrecede -> CWE-385\nCanPrecede -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Often primary in cryptographic applications and algorithms.\n\n**[Maintenance]** CWE 4.16 removed a demonstrative example for a hardware module because it was inaccurate and unable to be adapted. The CWE team is developing an alternative.\n\n\n\n### Observed Examples\n- **CVE-2019-10071:** Java-oriented framework compares HMAC signatures using String.equals() instead of a constant-time algorithm, causing timing discrepancies\n- **CVE-2019-10482:** Smartphone OS uses comparison functions that are not in constant time, allowing side channels\n- **CVE-2014-0984:** Password-checking function in router terminates validation of a password entry when it encounters the first incorrect character, which allows remote attackers to obtain passwords via a brute-force attack that relies on timing differences in responses to incorrect password guesses, aka a timing side-channel attack.\n\n\n\n\n## CWE-116: Improper Encoding or Escaping of Output\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.\n\n### Extended Description\n\n\nImproper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead.\n\n\nMost products follow a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, \"GET /index.html HTTP/1.1\" is a structured message containing a command (\"GET\") with a single argument (\"/index.html\") and metadata about which protocol version is being used (\"HTTP/1.1\").\n\n\nIf an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.\n\n\n### Alternative Terms\nOutput Sanitization\nOutput Validation\nOutput Encoding\n\n### Relationships\nChildOf -> CWE-707\nCanPrecede -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness is primary to all weaknesses related to injection (CWE-74) since the inherent nature of injection involves the violation of structured messages.\n\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\nHowever, input validation is not always sufficient, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise neutralized. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n**[Terminology]** The usage of the \"encoding\" and \"escaping\" terms varies widely. For example, in some programming languages, the terms are used interchangeably, while other languages provide APIs that use both terms for different tasks. This overlapping usage extends to the Web, such as the \"escape\" JavaScript function whose purpose is stated to be encoding. The concepts of encoding and escaping predate the Web by decades. Given such a context, it is difficult for CWE to adopt a consistent vocabulary that will not be misinterpreted by some constituency.\n\n**[Theoretical]** This is a data/directive boundary error in which data boundaries are not sufficiently enforced before it is sent to a different control sphere.\n\n**[Research Gap]** While many published vulnerabilities are related to insufficient output encoding, there is such an emphasis on input validation as a protection mechanism that the underlying causes are rarely described. Within CVE, the focus is primarily on well-understood issues like cross-site scripting and SQL injection. It is likely that this weakness frequently occurs in custom protocols that support multiple encodings, which are not necessarily detectable with automated techniques.\n\n\n\n### Observed Examples\n- **CVE-2021-41232:** Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90)\n- **CVE-2008-4636:** OS command injection in backup software using shell metacharacters in a filename; correct behavior would require that this filename could not be changed.\n- **CVE-2008-0769:** Web application does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.\n\n\n\n\n## CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe web application improperly neutralizes user-controlled input for executable script disguised with URI encodings.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-79\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2005-0563:** Cross-site scripting (XSS) vulnerability in Microsoft Outlook Web Access (OWA) component in Exchange Server 5.5 allows remote attackers to inject arbitrary web script or HTML via an email message with an encoded javascript: URL (\"jav&#X41sc&#0010;ript:\") in an IMG tag.\n- **CVE-2005-2276:** Cross-site scripting (XSS) vulnerability in Novell Groupwise WebAccess 6.5 before July 11, 2005 allows remote attackers to inject arbitrary web script or HTML via an e-mail message with an encoded javascript URI (e.g. \"j&#X41vascript\" in an IMG tag).\n- **CVE-2005-0692:** Encoded script within BBcode IMG tag.\n\n\n\n\n## CWE-385: Covert Timing Channel\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nCovert timing channels convey information by modulating some aspect of system behavior over time, so that the program receiving the information can observe system behavior and infer protected information.\n\n### Extended Description\n\n\nIn some instances, knowing when data is transmitted between parties can provide a malicious user with privileged information. Also, externally monitoring the timing of operations can potentially reveal sensitive data. For example, a cryptographic operation can expose its internal state if the time it takes to perform the operation varies, based on the state.\n\n\nCovert channels are frequently classified as either storage or timing channels. Some examples of covert timing channels are the system's paging rate, the time a certain transaction requires to execute, and the time it takes to gain access to a shared bus.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-514\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10.\n\n\n\n\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.\n\n### Extended Description\n\n\n HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. \n\n\nWhen an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as \"splitting\" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \\r, and LF is line feed, also given by %0a or \\n.\n\n\nIn addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \\t) and SP (space, also given as + sign or %20).\n\n\nThese types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second \"split\" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.\n\n\nHTTP response splitting weaknesses may be present when:\n\n\n  1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\n  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.\n\n\n\n### Alternative Terms\nHTTP Request Splitting\nHTTP Response Splitting\n\n### Relationships\nChildOf -> CWE-93\nCanPrecede -> CWE-79\nChildOf -> CWE-20\nChildOf -> CWE-436\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning\n- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs\n- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request\n\n\n\n\n## CWE-918: Server-Side Request Forgery (SSRF)\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nXSPA: Cross Site Port Attack\nSSRF: Server-Side Request Forgery\n\n### Relationships\nChildOf -> CWE-441\nChildOf -> CWE-610\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2023-32786:** Chain: LLM integration framework has prompt injection (CWE-1427) that allows an attacker to force the service to retrieve data from an arbitrary URL, essentially providing SSRF (CWE-918) and potentially injecting content into downstream tasks.\n- **CVE-2021-26855:** Server Side Request Forgery (SSRF) in mail server, as exploited in the wild per CISA KEV.\n- **CVE-2021-21973:** Server Side Request Forgery in cloud platform, as exploited in the wild per CISA KEV.\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\n**URL encoding error in development mode handler** in com.vaadinflow-server versions 2.0.0 through 2.6.1 (Vaadin 14.0.0 through 14.6.1), 3.0.0 through 6.0.9 (Vaadin 15.0.0 through 19.0.8) allows local user to execute arbitrary JavaScript code by opening crafted URL in browser.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **URL encoding error in development mode handler**\n- **impact:** execute arbitrary JavaScript code\n- **vector:** opening crafted URL in browser\n- **attacker:** local user\n- **product:** com.vaadinflow-server\n- **version:** 2.0.0 through 2.6.1, 3.0.0 through 6.0.9\n\n## CVE Reference Links Content Summary\nBased on the provided information, here's an analysis of CVE-2021-33604:\n\n**Root Cause of Vulnerability:**\nThe vulnerability stems from a URL encoding error in the development mode handler of Vaadin Flow server. Specifically, the webpack dev-server does not escape the `\"` character, which is not a valid URL character, and this limitation was not being checked when requests were passed to it via `DevModeHandlerImpl`.\n\n**Weaknesses/Vulnerabilities Present:**\n*   **Improper URL Sanitization:** The application fails to properly sanitize URLs before passing them to the webpack dev server.\n*   **Reflected Cross-Site Scripting (XSS):** The lack of proper encoding allows an attacker to inject malicious JavaScript code into the URL, which is then reflected back and executed within the context of the user's browser.\n\n**Impact of Exploitation:**\n*   **Arbitrary JavaScript Execution:** An attacker can execute arbitrary JavaScript code within the developer's browser by tricking them into opening a malicious URL.\n*   **Access to Local Vaadin Application:** If the developer has a Vaadin application running locally with sensitive data (e.g., a clone of a production database), the attacker could potentially gain access to it and its data.\n*   **Data Exfiltration:** Attackers could potentially exfiltrate the sensitive data from the local development environment.\n\n**Attack Vectors:**\n*   **Crafted URL:** The attacker crafts a malicious URL containing JavaScript code that is not properly encoded.\n*   **External Website:** The developer is tricked into opening an external website that contains the malicious URL which in turn gets the XSS attack going.\n*   **Local User as Victim**: The attack targets a developer who has a local Vaadin application running with the frontend development server enabled.\n\n**Required Attacker Capabilities/Position:**\n*   **Awareness of Target:** The attacker must be aware of the specific Vaadin application running on the developer's system, including the Vaadin version and the data it exposes.\n*   **Ability to Create and Host Malicious Website:** The attacker needs to be able to create and host a web page or send the crafted URL directly to the victim.\n*   **Ability to Lure the Victim:** The attacker must be able to trick the developer into opening the crafted URL.\n\n**Additional Notes:**\n\n*   The vulnerability is only exploitable during development time on the developer's machine, not in deployed applications.\n*   The vulnerability was fixed by implementing proper URL sanitization and encoding for requests to the webpack dev-server.\n\n**Versions Affected:**\n*   `com.vaadin:flow-server` versions 2.0.0 through 2.6.1 (Vaadin 14.0.0 through 14.6.1)\n*   `com.vaadin:flow-server` versions 3.0.0 through 6.0.9 (Vaadin 15.0.0 through 19.0.8)\n\n**Versions Fixed:**\n*   `com.vaadin:flow-server` version 2.6.2 and later (for Vaadin 14)\n*   `com.vaadin:flow-server` version 6.0.10 and later (for Vaadin 19)\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 177 | Improper Handling of URL Encoding (Hex Encoding) | Variant | Allowed | sparse | 0.449 |\n| 2 | 1295 | Debug Messages Revealing Unnecessary Information | Base | Allowed | sparse | 0.305 |\n| 3 | 1333 | Inefficient Regular Expression Complexity | Base | Allowed | sparse | 0.285 |\n| 4 | 208 | Observable Timing Discrepancy | Base | Allowed | sparse | 0.285 |\n| 5 | 116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | sparse | 0.285 |\n| 6 | 84 | Improper Neutralization of Encoded URI Schemes in a Web Page | Variant | Allowed | dense | 0.539 |\n| 7 | 385 | Covert Timing Channel | Base | Allowed | graph | 0.002 |\n| 8 | 79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | sparse | 0.267 |\n| 9 | 113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | sparse | 0.249 |\n| 10 | 918 | Server-Side Request Forgery (SSRF) | Base | Allowed | sparse | 0.248 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not properly handle when all or part of an input has been URL encoded.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-172\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2000-0900:** Hex-encoded path traversal variants - \"%2e%2e\", \"%2e%2e%2f\", \"%5c%2e%2e\"\n- **CVE-2005-2256:** Hex-encoded path traversal variants - \"%2e%2e\", \"%2e%2e%2f\", \"%5c%2e%2e\"\n- **CVE-2004-2121:** Hex-encoded path traversal variants - \"%2e%2e\", \"%2e%2e%2f\", \"%5c%2e%2e\"\n\n\n\n\n## CWE-1295: Debug Messages Revealing Unnecessary Information\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product fails to adequately prevent the revealing of unnecessary and potentially sensitive system information within debugging messages.\n\n### Extended Description\n\n\nDebug messages are messages that help troubleshoot an issue by revealing the internal state of the system. For example, debug data in design can be exposed through internal memory array dumps or boot logs through interfaces like UART via TAP commands, scan chain, etc. Thus, the more information contained in a debug message, the easier it is to debug. However, there is also the risk of revealing information that could help an attacker either decipher a vulnerability, and/or gain a better understanding of the system. Thus, this extra information could lower the \"security by obscurity\" factor. While \"security by obscurity\" alone is insufficient, it can help as a part of \"Defense-in-depth\". \n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-200\nPeerOf -> CWE-209\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2021-25476:** Digital Rights Management (DRM) capability for mobile platform leaks pointer information, simplifying ASLR bypass\n- **CVE-2020-24491:** Processor generates debug message that contains sensitive information (\"addresses of memory transactions\").\n- **CVE-2017-18326:** modem debug messages include cryptographic keys\n\n\n\n\n## CWE-1333: Inefficient Regular Expression Complexity\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.\n\n### Extended Description\nSome regular expression engines have a feature called \"backtracking\". If the token cannot match, the engine \"backtracks\" to a position that may result in a different token that can match.\n Backtracking becomes a weakness if all of these conditions are met:\n\n\n  - The number of possible backtracking attempts are exponential relative to the length of the input.\n\n  - The input can fail to match the regular expression.\n\n  - The input can be long enough.\n\n Attackers can create crafted inputs that intentionally cause the regular expression to use excessive backtracking in a way that causes the CPU consumption to spike. \n\n### Alternative Terms\nReDoS: ReDoS is an abbreviation of \"Regular expression Denial of Service\".\nRegular Expression Denial of Service: While this term is attack-focused, this is commonly used to describe the weakness.\nCatastrophic backtracking: This term is used to describe the behavior of the regular expression as a negative technical impact.\n\n### Relationships\nChildOf -> CWE-407\nChildOf -> CWE-407\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.\n- **CVE-2021-21317:** npm package for user-agent parser prone to ReDoS due to overlapping capture groups\n- **CVE-2019-16215:** Markdown parser uses inefficient regex when processing a message, allowing users to cause CPU consumption and delay preventing processing of other messages.\n\n\n\n\n## CWE-208: Observable Timing Discrepancy\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTwo separate operations in a product require different amounts of time to complete, in a way that is observable to an actor and reveals security-relevant information about the state of the product, such as whether a particular operation was successful or not.\n\n### Extended Description\nIn security-relevant contexts, even small variations in timing can be exploited by attackers to indirectly infer certain details about the product's internal operations. For example, in some cryptographic algorithms, attackers can use timing differences to infer certain properties about a private key, making the key easier to guess. Timing discrepancies effectively form a timing side channel.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-203\nCanPrecede -> CWE-385\nCanPrecede -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Often primary in cryptographic applications and algorithms.\n\n**[Maintenance]** CWE 4.16 removed a demonstrative example for a hardware module because it was inaccurate and unable to be adapted. The CWE team is developing an alternative.\n\n\n\n### Observed Examples\n- **CVE-2019-10071:** Java-oriented framework compares HMAC signatures using String.equals() instead of a constant-time algorithm, causing timing discrepancies\n- **CVE-2019-10482:** Smartphone OS uses comparison functions that are not in constant time, allowing side channels\n- **CVE-2014-0984:** Password-checking function in router terminates validation of a password entry when it encounters the first incorrect character, which allows remote attackers to obtain passwords via a brute-force attack that relies on timing differences in responses to incorrect password guesses, aka a timing side-channel attack.\n\n\n\n\n## CWE-116: Improper Encoding or Escaping of Output\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.\n\n### Extended Description\n\n\nImproper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead.\n\n\nMost products follow a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, \"GET /index.html HTTP/1.1\" is a structured message containing a command (\"GET\") with a single argument (\"/index.html\") and metadata about which protocol version is being used (\"HTTP/1.1\").\n\n\nIf an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.\n\n\n### Alternative Terms\nOutput Sanitization\nOutput Validation\nOutput Encoding\n\n### Relationships\nChildOf -> CWE-707\nCanPrecede -> CWE-74\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness is primary to all weaknesses related to injection (CWE-74) since the inherent nature of injection involves the violation of structured messages.\n\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\nHowever, input validation is not always sufficient, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise neutralized. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n**[Terminology]** The usage of the \"encoding\" and \"escaping\" terms varies widely. For example, in some programming languages, the terms are used interchangeably, while other languages provide APIs that use both terms for different tasks. This overlapping usage extends to the Web, such as the \"escape\" JavaScript function whose purpose is stated to be encoding. The concepts of encoding and escaping predate the Web by decades. Given such a context, it is difficult for CWE to adopt a consistent vocabulary that will not be misinterpreted by some constituency.\n\n**[Theoretical]** This is a data/directive boundary error in which data boundaries are not sufficiently enforced before it is sent to a different control sphere.\n\n**[Research Gap]** While many published vulnerabilities are related to insufficient output encoding, there is such an emphasis on input validation as a protection mechanism that the underlying causes are rarely described. Within CVE, the focus is primarily on well-understood issues like cross-site scripting and SQL injection. It is likely that this weakness frequently occurs in custom protocols that support multiple encodings, which are not necessarily detectable with automated techniques.\n\n\n\n### Observed Examples\n- **CVE-2021-41232:** Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90)\n- **CVE-2008-4636:** OS command injection in backup software using shell metacharacters in a filename; correct behavior would require that this filename could not be changed.\n- **CVE-2008-0769:** Web application does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.\n\n\n\n\n## CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe web application improperly neutralizes user-controlled input for executable script disguised with URI encodings.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-79\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2005-0563:** Cross-site scripting (XSS) vulnerability in Microsoft Outlook Web Access (OWA) component in Exchange Server 5.5 allows remote attackers to inject arbitrary web script or HTML via an email message with an encoded javascript: URL (\"jav&#X41sc&#0010;ript:\") in an IMG tag.\n- **CVE-2005-2276:** Cross-site scripting (XSS) vulnerability in Novell Groupwise WebAccess 6.5 before July 11, 2005 allows remote attackers to inject arbitrary web script or HTML via an e-mail message with an encoded javascript URI (e.g. \"j&#X41vascript\" in an IMG tag).\n- **CVE-2005-0692:** Encoded script within BBcode IMG tag.\n\n\n\n\n## CWE-385: Covert Timing Channel\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nCovert timing channels convey information by modulating some aspect of system behavior over time, so that the program receiving the information can observe system behavior and infer protected information.\n\n### Extended Description\n\n\nIn some instances, knowing when data is transmitted between parties can provide a malicious user with privileged information. Also, externally monitoring the timing of operations can potentially reveal sensitive data. For example, a cryptographic operation can expose its internal state if the time it takes to perform the operation varies, based on the state.\n\n\nCovert channels are frequently classified as either storage or timing channels. Some examples of covert timing channels are the system's paging rate, the time a certain transaction requires to execute, and the time it takes to gain access to a shared bus.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-514\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10.\n\n\n\n\n\n\n## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.\n\n### Extended Description\n\n\nCross-site scripting (XSS) vulnerabilities occur when:\n\n\n  1. Untrusted data enters a web application, typically from a web request.\n\n  1. The web application dynamically generates a web page that contains this untrusted data.\n\n  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.\n\n  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.\n\n  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.\n\n  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.\n\nThere are three main kinds of XSS:\n\n  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.\n\n  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. \n\n  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. \n\nOnce the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as \"drive-by hacking.\"\n\nIn many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.\n\n\n### Alternative Terms\nXSS: A common abbreviation for Cross-Site Scripting.\nHTML Injection: Used as a synonym of stored (Type 2) XSS.\nCSS: In the early years after initial discovery of XSS, \"CSS\" was a commonly-used acronym. However, this would cause confusion with \"Cascading Style Sheets,\" so usage of this acronym has declined significantly.\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nCanPrecede -> CWE-494\nPeerOf -> CWE-352\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThere can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.\n\n\n**[Applicable Platform]** \n\nXSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.\n\n\n\n\n### Observed Examples\n- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.\n- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.\n- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.\n\n### Extended Description\n\n\n HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. \n\n\nWhen an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as \"splitting\" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \\r, and LF is line feed, also given by %0a or \\n.\n\n\nIn addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \\t) and SP (space, also given as + sign or %20).\n\n\nThese types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second \"split\" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.\n\n\nHTTP response splitting weaknesses may be present when:\n\n\n  1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\n  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.\n\n\n\n### Alternative Terms\nHTTP Request Splitting\nHTTP Response Splitting\n\n### Relationships\nChildOf -> CWE-93\nCanPrecede -> CWE-79\nChildOf -> CWE-20\nChildOf -> CWE-436\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning\n- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs\n- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request\n\n\n\n\n## CWE-918: Server-Side Request Forgery (SSRF)\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nXSPA: Cross Site Port Attack\nSSRF: Server-Side Request Forgery\n\n### Relationships\nChildOf -> CWE-441\nChildOf -> CWE-610\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2023-32786:** Chain: LLM integration framework has prompt injection (CWE-1427) that allows an attacker to force the service to retrieve data from an arbitrary URL, essentially providing SSRF (CWE-918) and potentially injecting content into downstream tasks.\n- **CVE-2021-26855:** Server Side Request Forgery (SSRF) in mail server, as exploited in the wild per CISA KEV.\n- **CVE-2021-21973:** Server Side Request Forgery in cloud platform, as exploited in the wild per CISA KEV.\n\n"
  },
  "timestamp": "2025-03-30 17:13:08",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "79",
      "name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
      "score": 7902.343272684522,
      "search_source": "unknown"
    },
    {
      "cwe_id": "113",
      "name": "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')",
      "score": 7885.698089763357,
      "search_source": "unknown"
    },
    {
      "cwe_id": "116",
      "name": "Improper Encoding or Escaping of Output",
      "score": 7803.164635227125,
      "search_source": "unknown"
    },
    {
      "cwe_id": "918",
      "name": "Server-Side Request Forgery (SSRF)",
      "score": 7324.802071079958,
      "search_source": "unknown"
    },
    {
      "cwe_id": "1333",
      "name": "Inefficient Regular Expression Complexity",
      "score": 7263.353819879423,
      "search_source": "unknown"
    }
  ]
}