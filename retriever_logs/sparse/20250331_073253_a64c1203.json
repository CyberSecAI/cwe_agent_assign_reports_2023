{
  "retriever": "sparse",
  "query": "## Vulnerability Description\nA **memory corruption** vulnerability exists in the libpthread linuxthreads functionality of uClibC 0.9.33.2 and uClibC-ng 1.0.40. Thread allocation can lead to **memory corruption**. An attacker can create threads to trigger this vulnerability.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper memory management**\n- **weakness:** **memory corruption**\n- **product:** uClibC\n- **version:** 0.9.33.2 and 1.0.40\n- **component:** libpthread linuxthreads\n\n## CVE Reference Links Content Summary\n- **Root cause of vulnerability**: The vulnerability stems from the way `pthread_create` allocates thread stacks using `mmap` with the `MAP_FIXED` flag in uClibC and uClibC-ng's libpthread implementations. Specifically, the thread stack address is calculated by decrementing from a fixed start address, and with each thread creation, the address decreases. Due to the use of `MAP_FIXED`, when a large number of threads are created, these stack allocations eventually overwrite existing memory mappings, including libraries and the application's own code.\n\n- **Weaknesses/vulnerabilities present**:\n    - Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    - Incorrect use of `mmap` with `MAP_FIXED`.\n    - Predictable stack address allocation for threads.\n    - Lack of validation for stack address, leading to potential overwriting of existing mappings.\n\n- **Impact of exploitation**:\n    - Memory corruption due to overwriting of memory regions.\n    - Application crash or unexpected behavior.\n    - Potential for arbitrary code execution if the attacker can control the content of the overwritten memory.\n\n- **Attack vectors**:\n    - Creation of a large number of threads.\n    - This can be triggered remotely if the application exposes an interface that allows for the creation of multiple threads.\n\n- **Required attacker capabilities/position**:\n    - Ability to trigger the creation of multiple threads in the affected application.\n    - No specific privileges are required, but the application must use the vulnerable version of libpthread\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 787 | Out-of-bounds Write | Base | Allowed | alternate_terms | 1.000 |\n| 2 | 197 | Numeric Truncation Error | Base | Allowed | sparse | 0.262 |\n| 3 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.261 |\n| 4 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.258 |\n| 5 | 330 | Use of Insufficiently Random Values | Class | Discouraged | sparse | 0.231 |\n| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.536 |\n| 7 | 124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | graph | 0.002 |\n| 8 | 415 | Double Free | Variant | Allowed | sparse | 0.231 |\n| 9 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.227 |\n| 10 | 134 | Use of Externally-Controlled Format String | Base | Allowed | sparse | 0.226 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-787: Out-of-bounds Write\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product writes data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMemory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.\n- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.\n- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-197: Numeric Truncation Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTruncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.\n\n### Extended Description\nWhen a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-681\nChildOf -> CWE-681\nChildOf -> CWE-681\nCanAlsoBe -> CWE-195\nCanAlsoBe -> CWE-196\nCanAlsoBe -> CWE-192\nCanAlsoBe -> CWE-194\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** This weakness has traditionally been under-studied and under-reported, although vulnerabilities in popular software have been published in 2008 and 2009.\n\n\n\n### Observed Examples\n- **CVE-2020-17087:** Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.\n- **CVE-2009-0231:** Integer truncation of length value leads to heap-based buffer overflow.\n- **CVE-2008-3282:** Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.\n\n\n\n\n## CWE-770: Allocation of Resources Without Limits or Throttling\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.\n\n### Extended Description\n\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-400\nChildOf -> CWE-665\nChildOf -> CWE-400\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771).\n\n**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2009-4017:** Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..\n- **CVE-2009-2726:** Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-330: Use of Insufficiently Random Values\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product uses insufficiently random numbers or values in a security context that depends on unpredictable numbers.\n\n### Extended Description\nWhen product generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that will be generated, and use this guess to impersonate another user or access sensitive information.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\nCanPrecede -> CWE-804\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This can be primary to many other weaknesses such as cryptographic errors, authentication errors, symlink following, information leaks, and others.\n\n**[Maintenance]** As of CWE 4.3, CWE-330 and its descendants are being investigated by the CWE crypto team to identify gaps related to randomness and unpredictability, as well as the relationships between randomness and cryptographic primitives. This \"subtree analysis\" might result in the addition or deprecation of existing entries; the reorganization of relationships in some views, e.g. the research view (CWE-1000); more consistent use of terminology; and/or significant modifications to related entries.\n\n**[Maintenance]** As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios.\n\n\n\n### Observed Examples\n- **CVE-2021-3692:** PHP framework uses mt_rand() function (Marsenne Twister) when generating tokens\n- **CVE-2020-7010:** Cloud application on Kubernetes generates passwords using a weak random number generator based on deployment time.\n- **CVE-2009-3278:** Crypto product uses rand() library function to generate a recovery key, making it easier to conduct brute force attacks.\n\n\n\n\n## CWE-401: Missing Release of Memory after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.\n\n### Extended Description\nThis is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.\n\n### Alternative Terms\nMemory Leak\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is often a resultant weakness due to improper handling of malformed data or early termination of sessions.\n\n**[Terminology]** \"memory leak\" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict).\n\n\n\n### Observed Examples\n- **CVE-2005-3119:** Memory leak because function does not free() an element of a data structure.\n- **CVE-2004-0427:** Memory leak when counter variable is not decremented.\n- **CVE-2002-0574:** chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.\n\n\n\n\n## CWE-124: Buffer Underwrite ('Buffer Underflow')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.\n\n### Extended Description\nThis typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.\n\n### Alternative Terms\nbuffer underrun: Some prominent vendors and researchers use the term \"buffer underrun\". \"Buffer underflow\" is more commonly used, although both terms are also sometimes used to describe a buffer under-read (CWE-127).\n\n### Relationships\nChildOf -> CWE-786\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This could be resultant from several errors, including a bad offset or an array index that decrements before the beginning of the buffer (see CWE-129).\n\n\n\n### Observed Examples\n- **CVE-2021-24018:** buffer underwrite in firmware verification routine allows code execution via a crafted firmware image\n- **CVE-2002-2227:** Unchecked length of SSLv2 challenge value leads to buffer underflow.\n- **CVE-2007-4580:** Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130)\n\n\n\n\n## CWE-415: Double Free\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.\n\n### Extended Description\nWhen a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.\n\n### Alternative Terms\nDouble-free\n\n### Relationships\nChildOf -> CWE-825\nChildOf -> CWE-1341\nChildOf -> CWE-672\nChildOf -> CWE-672\nChildOf -> CWE-672\nChildOf -> CWE-666\nPeerOf -> CWE-416\nPeerOf -> CWE-123\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is usually resultant from another weakness, such as an unhandled error or race condition between threads. It could also be primary to weaknesses such as buffer overflows.\n\n**[Theoretical]** It could be argued that Double Free would be most appropriately located as a child of \"Use after Free\", but \"Use\" and \"Release\" are considered to be distinct operations within vulnerability theory, therefore this is more accurately \"Release of a Resource after Expiration or Release\", which doesn't exist yet.\n\n\n\n### Observed Examples\n- **CVE-2006-5051:** Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).\n- **CVE-2004-0642:** Double free resultant from certain error conditions.\n- **CVE-2004-0772:** Double free resultant from certain error conditions.\n\n\n\n\n## CWE-667: Improper Locking\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.\n\n### Extended Description\n\n\nLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.\n\n\n\n### Observed Examples\n- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.\n- **CVE-2009-0935:** Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice\n- **CVE-2010-4210:** function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.\n\n\n\n\n## CWE-134: Use of Externally-Controlled Format String\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source.\n\n### Extended Description\n\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-668\nChildOf -> CWE-668\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any programming language that support format strings.\n\n\n**[Other]** \n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n\n\n**[Research Gap]** Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.\n\n\n\n### Observed Examples\n- **CVE-2002-1825:** format string in Perl program\n- **CVE-2001-0717:** format string in bad call to syslog function\n- **CVE-2002-0573:** format string in bad call to syslog function\n\n",
  "keyphrases": {},
  "timestamp": "2025-03-31 07:32:53",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 7276.661027005785,
      "search_source": "base_query"
    },
    {
      "cwe_id": "197",
      "name": "Numeric Truncation Error",
      "score": 6849.602803951329,
      "search_source": "base_query"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 6776.556385931584,
      "search_source": "base_query"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 6637.179818091672,
      "search_source": "base_query"
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "score": 6589.990104964356,
      "search_source": "base_query"
    }
  ]
}