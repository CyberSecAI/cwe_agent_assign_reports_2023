{
  "retriever": "sparse",
  "query": "## Vulnerability Description\n**Use of a Broken or Risky Cryptographic Algorithm** vulnerability exists in homeLYnk (Wiser For KNX) and spaceLYnk V2.60 and prior that could cause unauthorized access when credentials are discovered after a brute force attack.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **Use of a Broken or Risky Cryptographic Algorithm**\n- **impact:** unauthorized access\n- **product:** homeLYnk and spaceLYnk\n- **version:** V2.60 and prior\n\n## CVE Reference Links Content Summary\nBased on the provided data, here's an analysis of the potential vulnerability, keeping in mind that the content is from a PDF file embedded within an HTML structure. This analysis is limited to inferences based on the document name and structure:\n\n**1. Relationship to CVE-2021-22738:**\n\n   - The content is **potentially related** to CVE-2021-22738. The file names \"SEVD-2021-130-04\\_homeLYnk\\_Wiser\\_for\\_KNX\\_spaceLYnk\\_Security\\_Notification.pdf\" and \"sevd-2021-130-04.json\" strongly suggest a security notification for Schneider Electric products, namely \"homeLYnk\", \"Wiser for KNX,\" and \"spaceLYnk.\" This type of notification is often linked to a CVE. The \"2021-130-04\" part might refer to a specific batch of fixes or an internal tracking number which further suggests that it might be tied to the specified CVE. However, without the actual content from the PDF, this remains an inference.\n\n**2. Extracted Information (Inferences):**\nGiven the file name and structure, the analysis can only extrapolate.\n\n   - **Root Cause of Vulnerability:** Cannot be determined from this metadata. The root cause will be detailed in the PDF. It's likely to be a flaw in the software or firmware of the listed Schneider Electric devices (homeLYnk, Wiser for KNX, or spaceLYnk), given that these are Schneider Electric products. It could also be a weakness in communication protocols.\n   - **Weaknesses/Vulnerabilities Present:** This cannot be precisely determined. Based on \"Security_Notification\", it is possible that there are multiple vulnerabilities. Common vulnerabilities for these types of devices include: insecure API endpoints, weak authentication, insecure firmware updates, or injection vulnerabilities in web interfaces.\n   - **Impact of Exploitation:** The notification suggests a security issue, which means the impact could be significant. This might include unauthorized access, data breaches, remote control of the devices, denial-of-service attacks, or manipulation of the connected systems.\n   - **Attack Vectors:** The attack vectors are currently unclear, however, they likely involve the network interface of the devices, either over IP networks or perhaps through the KNX communication bus. The JSON file suggests that this is being communicated using APIs/web interfaces.\n   - **Required Attacker Capabilities/Position:** Given the potential network vector, an attacker might need to be on the same network or have network access to the device. Successful exploitation could require knowledge of specific protocols or weaknesses. The \"spaceLYnk,\" \"Wiser for KNX,\" and \"homeLYnk\" names further suggest that a sophisticated attacker may be able to attack these devices via the KNX network.\n\n**3. Additional Notes:**\n\n    -   The file \"sevd-2021-130-04.json\" suggests that the notification is also provided in JSON format, indicating that the vulnerability information may also be machine readable and automatedly ingested by external systems for vulnerability reporting or automation.\n\n**4. Additional Information:**\n    -   More detail can be provided when the contents of the PDF and JSON files can be accessed, parsed and analyzed.\n\n**Conclusion:**\n   The provided content is likely related to a security issue (possibly CVE-2021-22738) affecting Schneider Electric's \"homeLYnk,\" \"Wiser for KNX,\" and \"spaceLYnk\" devices. However, the exact nature of the vulnerability, its root cause, attack vectors and impacts, cannot be determined without parsing the contents of the embedded PDF file.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 0.334 |\n| 2 | 1240 | Use of a Cryptographic Primitive with a Risky Implementation | Base | Allowed | sparse | 0.269 |\n| 3 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 0.254 |\n| 4 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 0.238 |\n| 5 | 328 | Use of Weak Hash | Base | Allowed | sparse | 0.237 |\n| 6 | 321 | Use of Hard-coded Cryptographic Key | Variant | Allowed | dense | 0.605 |\n| 7 | 259 | Use of Hard-coded Password | Variant | Allowed | graph | 0.002 |\n| 8 | 522 | Insufficiently Protected Credentials | Class | Allowed-with-Review | sparse | 0.225 |\n| 9 | 200 | Exposure of Sensitive Information to an Unauthorized Actor | Class | Discouraged | sparse | 0.225 |\n| 10 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 0.223 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product uses a broken or risky cryptographic algorithm or protocol.\n\n### Extended Description\n\n\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts.\n\n\nIt is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected.\n\n\nSince the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.\n\n\nFor a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\nPeerOf -> CWE-311\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-30273:** SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2008-3775:** Product uses \"ROT-25\" to obfuscate the password in the registry.\n\n\n\n\n## CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nTo fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.\n\n### Extended Description\n\n\nCryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of \"primitive\" can vary depending on point of view. See \"Terminology Notes\" for further explanation of some concepts.\n\n\nCryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time.\n\n\nIf a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is \"broken\"). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack.\n\n\nCryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered. As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly.\n\n\nIf ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences.\n\n\nThis weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** \n\n Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences.\n\n\nAs of CWE 4.6, CWE terminology around \"primitives\" and \"algorithms\" is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the \"cryptographic system\" would be AES-256-GCM with PKCS#5 formatting. The \"cryptographic function\" would be AES-256 in the GCM mode of operation, and the \"algorithm\" would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the \"cryptographic primitive,\" because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.\n\n\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2020-4778:** software uses MD5, which is less safe than the default SHA-256 used by related products\n- **CVE-2005-2946:** Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.\n- **CVE-2019-3907:** identity card uses MD5 hash of a salt and password\n\n\n\n\n## CWE-347: Improper Verification of Cryptographic Signature\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not verify, or incorrectly verifies, the cryptographic signature for data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1796:** Does not properly verify signatures for \"trusted\" entities.\n- **CVE-2005-2181:** Insufficient verification allows spoofing.\n- **CVE-2005-2182:** Insufficient verification allows spoofing.\n\n\n\n\n## CWE-916: Use of Password Hash With Insufficient Computational Effort\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.\n\n### Extended Description\n\n\nMany password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.\n\n\nMany hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.\n\n\nThere are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:\n\n\n  - The amount of CPU time required to compute the hash (\"stretching\")\n\n  - The amount of memory required to compute the hash (\"memory-hard\" operations)\n\n  - Including a random value, along with the password, as input to the hash computation (\"salting\")\n\n  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs (\"one-way\" hashing)\n\n  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (\"collision resistance\")\n\nNote that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-328\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2008-1526:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2006-1058:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2008-4905:** Blogging software uses a hard-coded salt when calculating a password hash.\n\n\n\n\n## CWE-328: Use of Weak Hash\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack).\n\n### Extended Description\n\n\nA hash function is defined as an algorithm that maps arbitrarily sized data into a fixed-sized digest (output) such that the following properties hold:\n\n\n  1. The algorithm is not invertible (also called \"one-way\" or \"not reversible\")\n\n  1. The algorithm is deterministic; the same input produces the same digest every time\n\n Building on this definition, a cryptographic hash function must also ensure that a malicious actor cannot leverage the hash function to have a reasonable chance of success at determining any of the following:\n\n  1. the original input (preimage attack), given only the digest\n\n  1. another input that can produce the same digest (2nd preimage attack), given the original input\n\n  1. a set of two or more inputs that evaluate to the same digest (birthday attack), given the actor can arbitrarily choose the inputs to be hashed and can do so a reasonable amount of times\n\nWhat is regarded as \"reasonable\" varies by context and threat model, but in general, \"reasonable\" could cover any attack that is more efficient than brute force (i.e., on average, attempting half of all possible combinations). Note that some attacks might be more efficient than brute force but are still not regarded as achievable in the real world.\n\nAny algorithm that does not meet the above conditions will generally be considered weak for general use in hashing.\n\n\nIn addition to algorithmic weaknesses, a hash function can be made weak by using the hash in a security context that breaks its security guarantees. For example, using a hash function without a salt for storing passwords (that are sufficiently short) could enable an adversary to create a \"rainbow table\" [REF-637] to recover the password under certain conditions; this attack works against such hash functions as MD5, SHA-1, and SHA-2.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-326\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries including CWE-328 have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2005-4900:** SHA-1 algorithm is not collision-resistant.\n- **CVE-2020-25685:** DNS product uses a weak hash (CRC32 or SHA-1) of the query name, allowing attacker to forge responses by computing domain names with the same hash.\n\n\n\n\n## CWE-321: Use of Hard-coded Cryptographic Key\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe use of a hard-coded cryptographic key significantly increases the possibility that encrypted data may be recovered.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-798\nChildOf -> CWE-798\nChildOf -> CWE-798\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** The main difference between the use of hard-coded passwords and the use of hard-coded cryptographic keys is the false sense of security that the former conveys. Many people believe that simply hashing a hard-coded password before storage will protect the information from malicious users. However, many hashes are reversible (or at least vulnerable to brute force attacks) -- and further, many authentication protocols simply request the hash itself, making it no better than a password.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-29960:** Engineering Workstation uses hard-coded cryptographic keys that could allow for unathorized filesystem access and privilege escalation\n- **CVE-2022-30271:** Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used by default.\n- **CVE-2020-10884:** WiFi router service has a hard-coded encryption key, allowing root access\n\n\n\n\n## CWE-259: Use of Hard-coded Password\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product contains a hard-coded password, which it uses for its own inbound authentication or for outbound communication to external components.\n\n### Extended Description\n\n\nA hard-coded password typically leads to a significant authentication failure that can be difficult for the system administrator to detect. Once detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations:\n\n```\n\t\tInbound: the product contains an authentication mechanism that checks for a hard-coded password.\n\t\tOutbound: the product connects to another system or component, and it contains hard-coded password for connecting to that component.\n```\nIn the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place.\n\nThe Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-798\nChildOf -> CWE-798\nChildOf -> CWE-798\nPeerOf -> CWE-321\nPeerOf -> CWE-257\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry could be split into multiple variants: an inbound variant (as seen in the second demonstrative example) and an outbound variant (as seen in the first demonstrative example). These variants are likely to have different consequences, detectability, etc. More importantly, from a vulnerability theory perspective, they could be characterized as different behaviors.\n\n\n\n### Observed Examples\n- **CVE-2022-29964:** Distributed Control System (DCS) has hard-coded passwords for local shell access\n- **CVE-2021-37555:** Telnet service for IoT feeder for dogs and cats has hard-coded password [REF-1288]\n- **CVE-2021-35033:** Firmware for a WiFi router uses a hard-coded password for a BusyBox shell, allowing bypass of authentication through the UART port\n\n\n\n\n## CWE-522: Insufficiently Protected Credentials\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-1390\nChildOf -> CWE-287\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2022-30018:** A messaging platform serializes all elements of User/Group objects, making private information available to adversaries\n- **CVE-2022-29959:** Initialization file contains credentials that can be decoded using a \"simple string transformation\"\n- **CVE-2022-35411:** Python-based RPC framework enables pickle functionality by default, allowing clients to unpickle untrusted data.\n\n\n\n\n## CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.\n\n### Extended Description\n\n\nThere are many different kinds of mistakes that introduce information exposures. The severity of the error can range widely, depending on the context in which the product operates, the type of sensitive information that is revealed, and the benefits it may provide to an attacker. Some kinds of sensitive information include:\n\n\n  - private, personal information, such as personal messages, financial data, health records, geographic location, or contact details\n\n  - system status and environment, such as the operating system and installed packages\n\n  - business secrets and intellectual property\n\n  - network status and configuration\n\n  - the product's own code or internal state\n\n  - metadata, e.g. logging of connections or message headers\n\n  - indirect information, such as a discrepancy between two internal operations that can be observed by an outsider\n\nInformation might be sensitive to different parties, each of which may have their own expectations for whether the information should be protected. These parties include:\n\n  - the product's own users\n\n  - people or organizations whose information is created or used by the product, even if they are not direct product users\n\n  - the product's administrators, including the admins of the system(s) and/or networks on which the product operates\n\n  - the developer\n\nInformation exposures can occur in different ways:\n\n  - the code  **explicitly inserts**  sensitive information into resources or messages that are intentionally made accessible to unauthorized actors, but should not contain the information - i.e., the information should have been \"scrubbed\" or \"sanitized\"\n\n  - a different weakness or mistake  **indirectly inserts**  the sensitive information into resources, such as a web script error revealing the full system path of the program.\n\n  - the code manages resources that intentionally contain sensitive information, but the resources are  **unintentionally made accessible**  to unauthorized actors. In this case, the information exposure is resultant - i.e., a different weakness enabled the access to the information in the first place.\n\nIt is common practice to describe any loss of confidentiality as an \"information exposure,\" but this can lead to overuse of CWE-200 in CWE mapping. From the CWE perspective, loss of confidentiality is a technical impact that can arise from dozens of different weaknesses, such as insecure file permissions or out-of-bounds read. CWE-200 and its lower-level descendants are intended to cover the mistakes that occur in behaviors that explicitly manage, store, transfer, or cleanse sensitive information.\n\n### Alternative Terms\nInformation Disclosure: This term is frequently used in vulnerability advisories to describe a consequence or technical impact, for any vulnerability that has a loss of confidentiality. Often, CWE-200 can be misused to represent the loss of confidentiality, even when the mistake - i.e., the weakness - is not directly related to the mishandling of the information itself, such as an out-of-bounds read that accesses sensitive memory contents; here, the out-of-bounds read is the primary weakness, not the disclosure of the memory. In addition, this phrase is also used frequently in policies and legal documents, but it does not refer to any disclosure of security-relevant information.\nInformation Leak: This is a frequently used term, however the \"leak\" term has multiple uses within security. In some cases it deals with the accidental exposure of information from a different weakness, but in other cases (such as \"memory leak\"), this deals with improper tracking of resources, which can lead to exhaustion. As a result, CWE is actively avoiding usage of the \"leak\" term.\n\n### Relationships\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-200 is commonly misused to represent the loss of confidentiality in a vulnerability, but confidentiality loss is a technical impact - not a root cause error. As of CWE 4.9, over 400 CWE entries can lead to a loss of confidentiality. Other options are often available. [REF-1287].\n**Comments:** If an error or mistake causes information to be disclosed, then use the CWE ID for that error. Consider starting with improper authorization (CWE-285), insecure permissions (CWE-732), improper authentication (CWE-287), etc. Also consider children such as Insertion of Sensitive Information Into Sent Data (CWE-201), Observable Discrepancy (CWE-203), Insertion of Sensitive Information into Externally-Accessible File or Directory (CWE-538), or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Maintenance]** As a result of mapping analysis in the 2020 Top 25 and more recent versions, this weakness is under review, since it is frequently misused in mapping to cover many problems that lead to loss of confidentiality. See Mapping Notes, Extended Description, and Alternate Terms.\n\n\n\n### Observed Examples\n- **CVE-2022-31162:** Rust library leaks Oauth client details in application debug logs\n- **CVE-2021-25476:** Digital Rights Management (DRM) capability for mobile platform leaks pointer information, simplifying ASLR bypass\n- **CVE-2001-1483:** Enumeration of valid usernames based on inconsistent responses\n\n\n\n\n## CWE-1390: Weak Authentication\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product uses an authentication mechanism to restrict access to specific users or identities, but the mechanism does not sufficiently prove that the claimed identity is correct.\n\n### Extended Description\n\n\nAttackers may be able to bypass weak authentication faster and/or with less effort than expected.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-287\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2022-30034:** Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).\n- **CVE-2022-35248:** Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication\n- **CVE-2021-3116:** Chain: Python-based HTTP Proxy server uses the wrong boolean operators (CWE-480) causing an incorrect comparison (CWE-697) that identifies an authN failure if all three conditions are met instead of only one, allowing bypass of the proxy authentication (CWE-1390)\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\n**Use of a Broken or Risky Cryptographic Algorithm** vulnerability exists in homeLYnk (Wiser For KNX) and spaceLYnk V2.60 and prior that could cause unauthorized access when credentials are discovered after a brute force attack.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **Use of a Broken or Risky Cryptographic Algorithm**\n- **impact:** unauthorized access\n- **product:** homeLYnk and spaceLYnk\n- **version:** V2.60 and prior\n\n## CVE Reference Links Content Summary\nBased on the provided data, here's an analysis of the potential vulnerability, keeping in mind that the content is from a PDF file embedded within an HTML structure. This analysis is limited to inferences based on the document name and structure:\n\n**1. Relationship to CVE-2021-22738:**\n\n   - The content is **potentially related** to CVE-2021-22738. The file names \"SEVD-2021-130-04\\_homeLYnk\\_Wiser\\_for\\_KNX\\_spaceLYnk\\_Security\\_Notification.pdf\" and \"sevd-2021-130-04.json\" strongly suggest a security notification for Schneider Electric products, namely \"homeLYnk\", \"Wiser for KNX,\" and \"spaceLYnk.\" This type of notification is often linked to a CVE. The \"2021-130-04\" part might refer to a specific batch of fixes or an internal tracking number which further suggests that it might be tied to the specified CVE. However, without the actual content from the PDF, this remains an inference.\n\n**2. Extracted Information (Inferences):**\nGiven the file name and structure, the analysis can only extrapolate.\n\n   - **Root Cause of Vulnerability:** Cannot be determined from this metadata. The root cause will be detailed in the PDF. It's likely to be a flaw in the software or firmware of the listed Schneider Electric devices (homeLYnk, Wiser for KNX, or spaceLYnk), given that these are Schneider Electric products. It could also be a weakness in communication protocols.\n   - **Weaknesses/Vulnerabilities Present:** This cannot be precisely determined. Based on \"Security_Notification\", it is possible that there are multiple vulnerabilities. Common vulnerabilities for these types of devices include: insecure API endpoints, weak authentication, insecure firmware updates, or injection vulnerabilities in web interfaces.\n   - **Impact of Exploitation:** The notification suggests a security issue, which means the impact could be significant. This might include unauthorized access, data breaches, remote control of the devices, denial-of-service attacks, or manipulation of the connected systems.\n   - **Attack Vectors:** The attack vectors are currently unclear, however, they likely involve the network interface of the devices, either over IP networks or perhaps through the KNX communication bus. The JSON file suggests that this is being communicated using APIs/web interfaces.\n   - **Required Attacker Capabilities/Position:** Given the potential network vector, an attacker might need to be on the same network or have network access to the device. Successful exploitation could require knowledge of specific protocols or weaknesses. The \"spaceLYnk,\" \"Wiser for KNX,\" and \"homeLYnk\" names further suggest that a sophisticated attacker may be able to attack these devices via the KNX network.\n\n**3. Additional Notes:**\n\n    -   The file \"sevd-2021-130-04.json\" suggests that the notification is also provided in JSON format, indicating that the vulnerability information may also be machine readable and automatedly ingested by external systems for vulnerability reporting or automation.\n\n**4. Additional Information:**\n    -   More detail can be provided when the contents of the PDF and JSON files can be accessed, parsed and analyzed.\n\n**Conclusion:**\n   The provided content is likely related to a security issue (possibly CVE-2021-22738) affecting Schneider Electric's \"homeLYnk,\" \"Wiser for KNX,\" and \"spaceLYnk\" devices. However, the exact nature of the vulnerability, its root cause, attack vectors and impacts, cannot be determined without parsing the contents of the embedded PDF file.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 0.334 |\n| 2 | 1240 | Use of a Cryptographic Primitive with a Risky Implementation | Base | Allowed | sparse | 0.269 |\n| 3 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 0.254 |\n| 4 | 916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | sparse | 0.238 |\n| 5 | 328 | Use of Weak Hash | Base | Allowed | sparse | 0.237 |\n| 6 | 321 | Use of Hard-coded Cryptographic Key | Variant | Allowed | dense | 0.605 |\n| 7 | 259 | Use of Hard-coded Password | Variant | Allowed | graph | 0.002 |\n| 8 | 522 | Insufficiently Protected Credentials | Class | Allowed-with-Review | sparse | 0.225 |\n| 9 | 200 | Exposure of Sensitive Information to an Unauthorized Actor | Class | Discouraged | sparse | 0.225 |\n| 10 | 1390 | Weak Authentication | Class | Allowed-with-Review | sparse | 0.223 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product uses a broken or risky cryptographic algorithm or protocol.\n\n### Extended Description\n\n\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts.\n\n\nIt is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected.\n\n\nSince the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.\n\n\nFor a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\nPeerOf -> CWE-311\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-30273:** SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2008-3775:** Product uses \"ROT-25\" to obfuscate the password in the registry.\n\n\n\n\n## CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nTo fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.\n\n### Extended Description\n\n\nCryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of \"primitive\" can vary depending on point of view. See \"Terminology Notes\" for further explanation of some concepts.\n\n\nCryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time.\n\n\nIf a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is \"broken\"). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack.\n\n\nCryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered. As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly.\n\n\nIf ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences.\n\n\nThis weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** \n\n Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences.\n\n\nAs of CWE 4.6, CWE terminology around \"primitives\" and \"algorithms\" is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the \"cryptographic system\" would be AES-256-GCM with PKCS#5 formatting. The \"cryptographic function\" would be AES-256 in the GCM mode of operation, and the \"algorithm\" would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the \"cryptographic primitive,\" because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.\n\n\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2020-4778:** software uses MD5, which is less safe than the default SHA-256 used by related products\n- **CVE-2005-2946:** Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.\n- **CVE-2019-3907:** identity card uses MD5 hash of a salt and password\n\n\n\n\n## CWE-347: Improper Verification of Cryptographic Signature\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not verify, or incorrectly verifies, the cryptographic signature for data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1796:** Does not properly verify signatures for \"trusted\" entities.\n- **CVE-2005-2181:** Insufficient verification allows spoofing.\n- **CVE-2005-2182:** Insufficient verification allows spoofing.\n\n\n\n\n## CWE-916: Use of Password Hash With Insufficient Computational Effort\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.\n\n### Extended Description\n\n\nMany password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.\n\n\nMany hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.\n\n\nThere are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:\n\n\n  - The amount of CPU time required to compute the hash (\"stretching\")\n\n  - The amount of memory required to compute the hash (\"memory-hard\" operations)\n\n  - Including a random value, along with the password, as input to the hash computation (\"salting\")\n\n  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs (\"one-way\" hashing)\n\n  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs (\"collision resistance\")\n\nNote that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-328\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2008-1526:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2006-1058:** Router does not use a salt with a hash, making it easier to crack passwords.\n- **CVE-2008-4905:** Blogging software uses a hard-coded salt when calculating a password hash.\n\n\n\n\n## CWE-328: Use of Weak Hash\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack).\n\n### Extended Description\n\n\nA hash function is defined as an algorithm that maps arbitrarily sized data into a fixed-sized digest (output) such that the following properties hold:\n\n\n  1. The algorithm is not invertible (also called \"one-way\" or \"not reversible\")\n\n  1. The algorithm is deterministic; the same input produces the same digest every time\n\n Building on this definition, a cryptographic hash function must also ensure that a malicious actor cannot leverage the hash function to have a reasonable chance of success at determining any of the following:\n\n  1. the original input (preimage attack), given only the digest\n\n  1. another input that can produce the same digest (2nd preimage attack), given the original input\n\n  1. a set of two or more inputs that evaluate to the same digest (birthday attack), given the actor can arbitrarily choose the inputs to be hashed and can do so a reasonable amount of times\n\nWhat is regarded as \"reasonable\" varies by context and threat model, but in general, \"reasonable\" could cover any attack that is more efficient than brute force (i.e., on average, attempting half of all possible combinations). Note that some attacks might be more efficient than brute force but are still not regarded as achievable in the real world.\n\nAny algorithm that does not meet the above conditions will generally be considered weak for general use in hashing.\n\n\nIn addition to algorithmic weaknesses, a hash function can be made weak by using the hash in a security context that breaks its security guarantees. For example, using a hash function without a salt for storing passwords (that are sufficiently short) could enable an adversary to create a \"rainbow table\" [REF-637] to recover the password under certain conditions; this attack works against such hash functions as MD5, SHA-1, and SHA-2.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-326\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries including CWE-328 have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2005-4900:** SHA-1 algorithm is not collision-resistant.\n- **CVE-2020-25685:** DNS product uses a weak hash (CRC32 or SHA-1) of the query name, allowing attacker to forge responses by computing domain names with the same hash.\n\n\n\n\n## CWE-321: Use of Hard-coded Cryptographic Key\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe use of a hard-coded cryptographic key significantly increases the possibility that encrypted data may be recovered.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-798\nChildOf -> CWE-798\nChildOf -> CWE-798\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** The main difference between the use of hard-coded passwords and the use of hard-coded cryptographic keys is the false sense of security that the former conveys. Many people believe that simply hashing a hard-coded password before storage will protect the information from malicious users. However, many hashes are reversible (or at least vulnerable to brute force attacks) -- and further, many authentication protocols simply request the hash itself, making it no better than a password.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-29960:** Engineering Workstation uses hard-coded cryptographic keys that could allow for unathorized filesystem access and privilege escalation\n- **CVE-2022-30271:** Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used by default.\n- **CVE-2020-10884:** WiFi router service has a hard-coded encryption key, allowing root access\n\n\n\n\n## CWE-259: Use of Hard-coded Password\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product contains a hard-coded password, which it uses for its own inbound authentication or for outbound communication to external components.\n\n### Extended Description\n\n\nA hard-coded password typically leads to a significant authentication failure that can be difficult for the system administrator to detect. Once detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations:\n\n```\n\t\tInbound: the product contains an authentication mechanism that checks for a hard-coded password.\n\t\tOutbound: the product connects to another system or component, and it contains hard-coded password for connecting to that component.\n```\nIn the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place.\n\nThe Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-798\nChildOf -> CWE-798\nChildOf -> CWE-798\nPeerOf -> CWE-321\nPeerOf -> CWE-257\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry could be split into multiple variants: an inbound variant (as seen in the second demonstrative example) and an outbound variant (as seen in the first demonstrative example). These variants are likely to have different consequences, detectability, etc. More importantly, from a vulnerability theory perspective, they could be characterized as different behaviors.\n\n\n\n### Observed Examples\n- **CVE-2022-29964:** Distributed Control System (DCS) has hard-coded passwords for local shell access\n- **CVE-2021-37555:** Telnet service for IoT feeder for dogs and cats has hard-coded password [REF-1288]\n- **CVE-2021-35033:** Firmware for a WiFi router uses a hard-coded password for a BusyBox shell, allowing bypass of authentication through the UART port\n\n\n\n\n## CWE-522: Insufficiently Protected Credentials\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-1390\nChildOf -> CWE-287\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2022-30018:** A messaging platform serializes all elements of User/Group objects, making private information available to adversaries\n- **CVE-2022-29959:** Initialization file contains credentials that can be decoded using a \"simple string transformation\"\n- **CVE-2022-35411:** Python-based RPC framework enables pickle functionality by default, allowing clients to unpickle untrusted data.\n\n\n\n\n## CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.\n\n### Extended Description\n\n\nThere are many different kinds of mistakes that introduce information exposures. The severity of the error can range widely, depending on the context in which the product operates, the type of sensitive information that is revealed, and the benefits it may provide to an attacker. Some kinds of sensitive information include:\n\n\n  - private, personal information, such as personal messages, financial data, health records, geographic location, or contact details\n\n  - system status and environment, such as the operating system and installed packages\n\n  - business secrets and intellectual property\n\n  - network status and configuration\n\n  - the product's own code or internal state\n\n  - metadata, e.g. logging of connections or message headers\n\n  - indirect information, such as a discrepancy between two internal operations that can be observed by an outsider\n\nInformation might be sensitive to different parties, each of which may have their own expectations for whether the information should be protected. These parties include:\n\n  - the product's own users\n\n  - people or organizations whose information is created or used by the product, even if they are not direct product users\n\n  - the product's administrators, including the admins of the system(s) and/or networks on which the product operates\n\n  - the developer\n\nInformation exposures can occur in different ways:\n\n  - the code  **explicitly inserts**  sensitive information into resources or messages that are intentionally made accessible to unauthorized actors, but should not contain the information - i.e., the information should have been \"scrubbed\" or \"sanitized\"\n\n  - a different weakness or mistake  **indirectly inserts**  the sensitive information into resources, such as a web script error revealing the full system path of the program.\n\n  - the code manages resources that intentionally contain sensitive information, but the resources are  **unintentionally made accessible**  to unauthorized actors. In this case, the information exposure is resultant - i.e., a different weakness enabled the access to the information in the first place.\n\nIt is common practice to describe any loss of confidentiality as an \"information exposure,\" but this can lead to overuse of CWE-200 in CWE mapping. From the CWE perspective, loss of confidentiality is a technical impact that can arise from dozens of different weaknesses, such as insecure file permissions or out-of-bounds read. CWE-200 and its lower-level descendants are intended to cover the mistakes that occur in behaviors that explicitly manage, store, transfer, or cleanse sensitive information.\n\n### Alternative Terms\nInformation Disclosure: This term is frequently used in vulnerability advisories to describe a consequence or technical impact, for any vulnerability that has a loss of confidentiality. Often, CWE-200 can be misused to represent the loss of confidentiality, even when the mistake - i.e., the weakness - is not directly related to the mishandling of the information itself, such as an out-of-bounds read that accesses sensitive memory contents; here, the out-of-bounds read is the primary weakness, not the disclosure of the memory. In addition, this phrase is also used frequently in policies and legal documents, but it does not refer to any disclosure of security-relevant information.\nInformation Leak: This is a frequently used term, however the \"leak\" term has multiple uses within security. In some cases it deals with the accidental exposure of information from a different weakness, but in other cases (such as \"memory leak\"), this deals with improper tracking of resources, which can lead to exhaustion. As a result, CWE is actively avoiding usage of the \"leak\" term.\n\n### Relationships\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-200 is commonly misused to represent the loss of confidentiality in a vulnerability, but confidentiality loss is a technical impact - not a root cause error. As of CWE 4.9, over 400 CWE entries can lead to a loss of confidentiality. Other options are often available. [REF-1287].\n**Comments:** If an error or mistake causes information to be disclosed, then use the CWE ID for that error. Consider starting with improper authorization (CWE-285), insecure permissions (CWE-732), improper authentication (CWE-287), etc. Also consider children such as Insertion of Sensitive Information Into Sent Data (CWE-201), Observable Discrepancy (CWE-203), Insertion of Sensitive Information into Externally-Accessible File or Directory (CWE-538), or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Maintenance]** As a result of mapping analysis in the 2020 Top 25 and more recent versions, this weakness is under review, since it is frequently misused in mapping to cover many problems that lead to loss of confidentiality. See Mapping Notes, Extended Description, and Alternate Terms.\n\n\n\n### Observed Examples\n- **CVE-2022-31162:** Rust library leaks Oauth client details in application debug logs\n- **CVE-2021-25476:** Digital Rights Management (DRM) capability for mobile platform leaks pointer information, simplifying ASLR bypass\n- **CVE-2001-1483:** Enumeration of valid usernames based on inconsistent responses\n\n\n\n\n## CWE-1390: Weak Authentication\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product uses an authentication mechanism to restrict access to specific users or identities, but the mechanism does not sufficiently prove that the claimed identity is correct.\n\n### Extended Description\n\n\nAttackers may be able to bypass weak authentication faster and/or with less effort than expected.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-287\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2022-30034:** Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).\n- **CVE-2022-35248:** Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication\n- **CVE-2021-3116:** Chain: Python-based HTTP Proxy server uses the wrong boolean operators (CWE-480) causing an incorrect comparison (CWE-697) that identifies an authN failure if all three conditions are met instead of only one, allowing bypass of the proxy authentication (CWE-1390)\n\n"
  },
  "timestamp": "2025-03-30 20:10:38",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "1240",
      "name": "Use of a Cryptographic Primitive with a Risky Implementation",
      "score": 10344.891984004726,
      "search_source": "unknown"
    },
    {
      "cwe_id": "916",
      "name": "Use of Password Hash With Insufficient Computational Effort",
      "score": 9607.172891484131,
      "search_source": "unknown"
    },
    {
      "cwe_id": "327",
      "name": "Use of a Broken or Risky Cryptographic Algorithm",
      "score": 9340.02751963224,
      "search_source": "unknown"
    },
    {
      "cwe_id": "328",
      "name": "Use of Weak Hash",
      "score": 9273.511906691101,
      "search_source": "unknown"
    },
    {
      "cwe_id": "321",
      "name": "Use of Hard-coded Cryptographic Key",
      "score": 8609.154295006409,
      "search_source": "unknown"
    }
  ]
}