# Enhanced Query for CVE-2022-35106

## Vulnerability Description
SWFTools commit 772e55a2 was discovered to contain a segmentation violation via FoFiTrueTypecomputeTableChecksum(unsigned char*, int) at /xpdf/FoFiTrueType.cc.

### Vulnerability Description Key Phrases
- **impact:** segmentation violation
- **product:** SWFTools
- **version:** commit 772e55a2
- **component:** /xpdf/FoFiTrueType.cc

## CVE Reference Links Content Summary
The provided content is a GitHub issue report detailing multiple vulnerabilities found in swftools' `pdf2swf` utility. Here's a breakdown of the vulnerabilities:

**1. Heap-buffer-overflow in `DCTStream::readHuffSym`**

*   **Root Cause:** A heap buffer overflow occurs in the `DCTStream::readHuffSym` function when processing a crafted PDF file.
*   **Vulnerability:** Heap buffer overflow
*   **Impact:** Crash of the application.
*   **Attack Vector:** Maliciously crafted PDF file.
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The crash occurs when `DCTStream::readHuffSym` attempts to read data beyond the allocated buffer.

**2. Heap-buffer-overflow in `GfxICCBasedColorSpace::getDefaultColor`**

*   **Root Cause:** A heap buffer overflow occurs in `GfxICCBasedColorSpace::getDefaultColor` when parsing color space data within a crafted PDF.
*   **Vulnerability:** Heap buffer overflow
*   **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file with specific color space data.
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The overflow occurs when accessing an out-of-bounds memory location within the `getDefaultColor` function.

**3. Heap-buffer-overflow in `draw_stroke`**

*   **Root Cause:** A heap buffer overflow vulnerability is present within the `draw_stroke` function related to processing path drawing operations in a PDF file
*   **Vulnerability:** Heap buffer overflow
*   **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file.
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The `draw_stroke` function attempts to write data beyond the allocated buffer.

**4. Heap-buffer-overflow in `DCTStream::reset`**

*   **Root Cause:** A heap buffer overflow is triggered in `DCTStream::reset` during image stream processing.
*   **Vulnerability:** Heap buffer overflow
*  **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file.
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The vulnerability occurs when the reset function tries to write beyond the allocated buffer for the image stream.

**5. Stack-buffer-overflow in `ImageStream::getPixel`**

*   **Root Cause:** A stack buffer overflow in `ImageStream::getPixel` when handling image data in a PDF.
*   **Vulnerability:** Stack buffer overflow
*   **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file with specific image parameters
*  **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The `getPixel` function writes beyond the boundaries of a stack allocated buffer when processing image data.

**6. Global-buffer-overflow in `DCTStream::transformDataUnit`**

*   **Root Cause:** A global buffer overflow occurs within `DCTStream::transformDataUnit` when transforming data within a stream.
*   **Vulnerability:** Global buffer overflow
*   **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file.
*  **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The function attempts to read data outside of the allowed boundary of a global variable

**7. SEGV in `FoFiTrueType::writeTTF`**

*   **Root Cause:** A segmentation fault occurs within `FoFiTrueType::writeTTF`, likely due to a null pointer dereference when handling TrueType fonts.
*   **Vulnerability:** Segmentation Fault (likely null pointer dereference)
*  **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file with specific font usage.
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The crash occurs while processing font data, specifically in `writeTTF`.

**8. SEGV in `convert_gfxline`**
*   **Root Cause:** A segmentation fault occurs in `convert_gfxline` due to an invalid memory access when converting graphics lines.
*   **Vulnerability:** Segmentation Fault (likely invalid memory access).
*   **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file triggering specific path operations.
*  **Attacker Capability:** Ability to create or modify PDF files.
*  **Technical Details:** The crash occurs due to a dereference of a high value address within the `convert_gfxline` function.

**9. SEGV in `gfxline_getbbox`**
*   **Root Cause:** A segmentation fault occurs within `gfxline_getbbox` due to dereferencing a high value address when calculating the bounding box for a graphics line.
*   **Vulnerability:** Segmentation Fault (likely invalid memory access).
*  **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file that includes specific text or graphics.
*   **Attacker Capability:** Ability to create or modify PDF files.
*  **Technical Details:**  The function attempts to dereference an invalid memory address.

**10. SEGV in `memset` (via `InfoOutputDev::type3D0`)**

*   **Root Cause:** A segmentation fault within the `memset` function, triggered by `InfoOutputDev::type3D0`, likely due to an invalid memory pointer.
*   **Vulnerability:** Segmentation Fault (likely invalid memory access).
*   **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file.
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The crash occurs in `memset`, indicating a write to an invalid memory address that is likely triggered by calls within `InfoOutputDev::type3D0`

**11. SEGV in `InfoOutputDev::type3D1`**

*  **Root Cause:** A segmentation fault within `InfoOutputDev::type3D1`, due to a read memory access of an invalid address.
*  **Vulnerability:** Segmentation Fault (likely invalid memory access).
*  **Impact:** Application crash.
*  **Attack Vector:** Maliciously crafted PDF file.
*  **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** Crash occurs within `type3D1` due to invalid memory access, likely a dereference of a null or wild pointer

**12. SEGV in `FoFiTrueType::computeTableChecksum`**
*   **Root Cause:** A segmentation fault in `FoFiTrueType::computeTableChecksum` due to an attempt to read from an invalid memory address.
*   **Vulnerability:** Segmentation Fault (likely invalid memory access).
*   **Impact:** Application crash.
*   **Attack Vector:** Maliciously crafted PDF file including TrueType fonts.
*   **Attacker Capability:** Ability to create or modify PDF files.
*  **Technical Details:** The crash occurs within `computeTableChecksum` during the processing of font data.

**13. FPE (Floating Point Exception) in `DCTStream::readMCURow`**
*   **Root Cause:** A floating point exception within `DCTStream::readMCURow` indicates a division by zero or another invalid floating point operation
*   **Vulnerability:** Floating Point Exception
*   **Impact:** Application crash
*   **Attack Vector:** Maliciously crafted PDF file
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:**  The crash occurs during the processing of compressed image data.

**14. Out-of-memory in `draw_stroke`**
*   **Root Cause:** The program requests an allocation of a very large amount of memory, leading to an out of memory error.
*   **Vulnerability:** Out-of-memory
*   **Impact:** Application crash
*   **Attack Vector:** Maliciously crafted PDF file.
*   **Attacker Capability:** Ability to create or modify PDF files.
*   **Technical Details:** The `draw_stroke` function requests an extremely large amount of memory through malloc.

In summary, multiple vulnerabilities are present including heap overflows, stack overflows, global overflows, segmentation faults, floating point exceptions and out of memory issues. All of them are triggered through the processing of maliciously crafted PDF files.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|------------|-------------------|
| 1 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.057 |
| 2 | 476 | NULL Pointer Dereference | Base | Allowed | sparse | 0.052 |
| 3 | 681 | Incorrect Conversion between Numeric Types | Base | Allowed | sparse | 0.032 |
| 4 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.032 |
| 5 | 770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | sparse | 0.026 |
| 6 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | dense | 0.458 |
| 7 | 1325 | Improperly Controlled Sequential Memory Allocation | Base | Allowed | graph | 0.003 |
| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.026 |
| 9 | 194 | Unexpected Sign Extension | Variant | Allowed | sparse | 0.024 |
| 10 | 191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | sparse | 0.024 |



# Complete CWE Specifications


## CWE-125: Out-of-bounds Read
**Abstraction:** Base
**Status:** Draft

### Description
The product reads data past the end, or before the beginning, of the intended buffer.

### Extended Description
Not provided

### Alternative Terms
OOB read: Shorthand for "Out of bounds" read

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.
- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.
- **CVE-2014-0160:** Chain: "Heartbleed" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.




## CWE-476: NULL Pointer Dereference
**Abstraction:** Base
**Status:** Stable

### Description
The product dereferences a pointer that it expects to be valid but is NULL.

### Extended Description
Not provided

### Alternative Terms
NPD: Common abbreviation for Null Pointer Dereference
null deref: Common abbreviation for Null Pointer Dereference
NPE: Common abbreviation for Null Pointer Exception
nil pointer dereference: used for access of nil in Go programs

### Relationships
ChildOf -> CWE-710
ChildOf -> CWE-754
ChildOf -> CWE-754

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2005-3274:** race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.
- **CVE-2002-1912:** large number of packets leads to NULL dereference
- **CVE-2005-0772:** packet with invalid error status value triggers NULL dereference




## CWE-681: Incorrect Conversion between Numeric Types
**Abstraction:** Base
**Status:** Draft

### Description
When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-704
ChildOf -> CWE-704
CanPrecede -> CWE-682

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2022-2639:** Chain: integer coercion error (CWE-192) prevents a return value from indicating an error, leading to out-of-bounds write (CWE-787)
- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)
- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)




## CWE-122: Heap-based Buffer Overflow
**Abstraction:** Variant
**Status:** Draft

### Description
A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-788
ChildOf -> CWE-787

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.



### Observed Examples
- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)
- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)
- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).




## CWE-770: Allocation of Resources Without Limits or Throttling
**Abstraction:** Base
**Status:** Incomplete

### Description
The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.

### Extended Description


Code frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-400
ChildOf -> CWE-665
ChildOf -> CWE-400

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771).

**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. "Resource exhaustion" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.



### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2009-4017:** Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..
- **CVE-2009-2726:** Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.




## CWE-401: Missing Release of Memory after Effective Lifetime
**Abstraction:** Variant
**Status:** Draft

### Description
The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.

### Extended Description
This is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.

### Alternative Terms
Memory Leak

### Relationships
ChildOf -> CWE-772
ChildOf -> CWE-404
ChildOf -> CWE-404

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** This is often a resultant weakness due to improper handling of malformed data or early termination of sessions.

**[Terminology]** "memory leak" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict).



### Observed Examples
- **CVE-2005-3119:** Memory leak because function does not free() an element of a data structure.
- **CVE-2004-0427:** Memory leak when counter variable is not decremented.
- **CVE-2002-0574:** chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.




## CWE-1325: Improperly Controlled Sequential Memory Allocation
**Abstraction:** Base
**Status:** Incomplete

### Description
The product manages a group of objects or resources and performs a separate memory allocation for each object, but it does not properly limit the total amount of memory that is consumed by all of the combined objects.

### Extended Description


While the product might limit the amount of memory that is allocated in a single operation for a single object (such as a malloc of an array), if an attacker can cause multiple objects to be allocated in separate operations, then this might cause higher total memory consumption than the developer intended, leading to a denial of service.


### Alternative Terms
Stack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as "stack exhaustion," which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.

### Relationships
ChildOf -> CWE-770
PeerOf -> CWE-789
CanPrecede -> CWE-476

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2020-36049:** JavaScript-based packet decoder uses concatenation of many small strings, causing out-of-memory (OOM) condition
- **CVE-2019-20176:** Product allocates a new buffer on the stack for each file in a directory, allowing stack exhaustion
- **CVE-2013-1591:** Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.




## CWE-674: Uncontrolled Recursion
**Abstraction:** Class
**Status:** Draft

### Description
The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.

### Extended Description
Not provided

### Alternative Terms
Stack Exhaustion

### Relationships
ChildOf -> CWE-834

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction



### Observed Examples
- **CVE-2007-1285:** Deeply nested arrays trigger stack exhaustion.
- **CVE-2007-3409:** Self-referencing pointers create infinite loop and resultant stack exhaustion.
- **CVE-2016-10707:** Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.




## CWE-194: Unexpected Sign Extension
**Abstraction:** Variant
**Status:** Incomplete

### Description
The product performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type. When the original number is negative, this can produce unexpected values that lead to resultant weaknesses.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-681
ChildOf -> CWE-681
ChildOf -> CWE-681

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Additional Notes
**[Relationship]** Sign extension errors can lead to buffer overflows and other memory-based problems. They are also likely to be factors in other weaknesses that are not based on memory operations, but rely on numeric calculation.

**[Maintenance]** This entry is closely associated with signed-to-unsigned conversion errors (CWE-195) and other numeric errors. These relationships need to be more closely examined within CWE.



### Observed Examples
- **CVE-2018-10887:** Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125)
- **CVE-1999-0234:** Sign extension error produces -1 value that is treated as a command separator, enabling OS command injection.
- **CVE-2003-0161:** Product uses "char" type for input character. When char is implemented as a signed type, ASCII value 0xFF (255), a sign extension produces a -1 value that is treated as a program-specific separator value, effectively disabling a length check and leading to a buffer overflow. This is also a multiple interpretation error.




## CWE-191: Integer Underflow (Wrap or Wraparound)
**Abstraction:** Base
**Status:** Draft

### Description
The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.

### Extended Description
This can happen in signed and unsigned cases.

### Alternative Terms
Integer underflow: 

"Integer underflow" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.


"Integer underflow" is occasionally used to describe array index errors in which the index is negative.


### Relationships
ChildOf -> CWE-682
ChildOf -> CWE-682

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Observed Examples
- **CVE-2004-0816:** Integer underflow in firewall via malformed packet.
- **CVE-2004-1002:** Integer underflow by packet with invalid length.
- **CVE-2005-0199:** Long input causes incorrect length calculation.

